<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
<!ENTITY % comedilib_entities SYSTEM "comedilib.ent">
%comedilib_entities;
]>

<section id="writingprograms" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>
    Writing &comedi; programs
  </title>
  <para>
    This section describes how &comedi;
    can be used in an application, to communicate data with a set
    of &comedi; devices.
    <xref linkend="acquisitionfunctions"/> gives more details about
    the various acquisition functions with which the application
    programmer can perform data acquisition in &comedi;.
  </para>
  <para>
    Also don't forget to take a good look at the
    <filename class="directory">demo</filename>
    directory of the Comedilib source code. It contains lots of examples
    for the basic functionalities of &comedi;.
  </para>
  
  <section id="firstprogram">
    <title>
      Your first &comedi; program
    </title>
    
    <para>
      This example requires a card that has analog or digital input. This
      progam opens the device, gets the data, and prints it out:
      <programlisting>
	<xi:include href="../demo/tut1.c" parse="text"/>
      </programlisting>
    </para>
    <para>
      The source code file for the above program can be found in Comedilib,
      at <filename>demo/tut1.c</filename>.  You can compile the program using
    </para>
    
    <screen>
      cc tut1.c -lcomedi -o tut1
    </screen>
    <para>
      The
      <function>
	<link linkend="func-ref-comedi-open">comedi_open</link>
      </function> call can only be successful if the
      <filename>comedi0</filename> device file is configured with a
      valid &comedi; driver. <xref linkend="cardconfiguration"/> explains
      how this driver is linked to the <quote>device file</quote>.
    </para>
    <para>
      The <parameter class="function">range</parameter> variable tells
      &comedi; which gain to use when measuring an analog voltage.  Since we
      don't know (yet) which numbers are valid, or what each means, we'll
      use <literal>0</literal>, because it won't cause errors.  Likewise
      with <parameter class="function">aref</parameter>, which determines the
      analog reference used.
    </para>
  </section>


  <section id="convertingsamples">
    <title>
      Converting between integer data and physical units
    </title>
    
    <para>
      If you selected an analog input subdevice, you probably noticed
      that the output of <command>tut1</command> is an unsigned number, for
      example between <literal>0</literal> and <literal>65535</literal>
      for a 16 bit analog input. &comedi; samples are
      unsigned,
      with <literal>0</literal>  representing the lowest voltage of the ADC,
      and a hardware-dependent maximum value representing the highest voltage.
      &comedi; compensates for anything else the manual for
      your device says (for example, many boards represent bipolar
      analog input voltages as signed integers).  
      However, you probably prefer to have this number
      translated to a voltage.  Naturally, as a good programmer, your first
      question is: <quote>How do I do this in a device-independent
    manner?</quote>
    </para>
    
    <para>
      The functions
      <link linkend="func-ref-comedi-to-physical"><function>comedi_to_physical</function></link>, <link linkend="func-ref-comedi-to-phys"><function>comedi_to_phys</function></link>,
      <link linkend="func-ref-comedi-from-physical"><function>comedi_from_physical</function></link> and <link linkend="func-ref-comedi-from-phys"><function>comedi_from_phys</function></link>
      are used to convert between &comedi;'s integer data and floating point numbers corresponding
      to physical values (voltages, etc.).
    </para>
    
  </section>

  <section id="secondprogram">
    <title>
      Your second &comedi; program
    </title>
    
    
    <para>
      Actually, this is the first &comedi; program again, except
      we've added code to convert the integer data value to physical units.
    </para>
    
    <programlisting>
      <xi:include href="../demo/tut2.c" parse="text"/>
    </programlisting>
    <para>
      The source code file for the above program can be found in Comedilib, at demo/tut2.c.
    </para>
  </section>

  <section id="asyncprogram">
    <title>
      Asynchronous acquisition
    </title>
    <para>
      Of special importance is the so called
      "asynchronous data acquisition" where the &comedi; is sampling
      in the background at a given sample rate. The
      the user can retrieve the data whenever it is convenient.
      &comedi; stores the data in a ring-buffer so that
      programs can perform other tasks in the foreground, for example
      plotting data or interacting with the user. 
      This technique is used in programs such
      as <command>ktimetrace</command> or <command>comedirecord</command>.
    </para>
    <para>
      The program <command>tut3.c</command> demonstrates the
      asynchronous acquisition. The general strategy is always
      the same: first, we tell &comedi; all sampling parameters such as
      the sampling rate,
      the number of channels and anything it needs to know
      so that it can run independently in the background.
      Then &comedi; checks our request and it might
      modify it. For example we might want to have a sampling rate of
      16kHz but we only get 1kHz. Finally we can start
      the asynchronous acquisition. Once it is started we
      need to check periodically if data is available and
      request it from &comedi; so that its internal buffer
      won't overrun.
    </para>
    <para>
      The program below is a stripped down version
      of the program <command>cmd.c</command> in
      the demo directory. To compile it run:
    </para>
    <screen>
      gcc tut3.c -lcomedi -lm -o tut3
    </screen>
    <para>
      It requests data from two channels at 
      a sampling rate of 1kHz and a total of 10000 samples.
      which are then printed to stdout. You can pipe the data
      into a file and plot it with gnuplot. Central in this
      program is the loop using the standard C read command
      which receives the buffer contents. Below is an
      extract from <filename>tut3.c</filename> showing the
      relevant commands:
    </para>
    <programlisting>
      <xi:include href="../demo/tut3_part.c" parse="text"/>
    </programlisting>
  </section>
  
  <section>
    <title>Further examples</title>
    <para>
      See the demo subdirectory of Comedilib for more example programs.
      The directory contains
      a README file with descriptions of the various demo programs.
    </para>
  </section>
  
</section>
