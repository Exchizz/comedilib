  Comedi Documentation
  David Schleef ds@stm.lbl.gov, Frank Hess fmhess@uiuc.edu


  11..  IInnttrroodduuccttiioonn

  This is preliminary documentation for Comedi and Comedilib.


  22..  IInnssttaallllaattiioonn aanndd ccoonnffiigguurraattiioonn


  This section covers compiling, installing, and configuring comedi and
  comedlib.



  22..11..  CCoommppiilliinngg aanndd IInnssttaalllliinngg


  This section has not been written.



  22..22..  IInnssmmoodd''ddiinngg tthhee kkeerrnneell mmoodduullee


  This section has not been written.



  22..33..  CCoonnffiigguurriinngg ccoommeeddii ffoorr yyoouurr hhaarrddwwaarree



  I assume that your hardware device is in your computer, and that you
  know the relevant details about it, i.e., what kind of card it is, the
  I/O base, the IRQ, jumper settings related to input ranges, etc.

  To tell the comedi kernel module that you have a particular device,
  and some information about it, you will be running the comedi_config
  command.  Perhaps you should read the man page now.

  In this tutorial, I will go through the process of configuring comedi
  for two devices, a National Instruments AT-MIO-16E-10 and a Data
  Translation DT2821-F-8DI.

  The NI board is plug-and-play, and the man page tells me that I need
  to configure the PnP part of the board with isapnptools.  The
  isapnptools package is a little cryptic, but the concepts are simple.
  Once I learned how to use it, I settled on a /etc/isapnp.conf file
  that contained the lines:



       # ANSI string -->National Instruments, AT-MIO-16E-10<--
       (CONFIGURE NIC2400/10725401 (LD 0
               (IO 0 (BASE 0x0260))
               (INT 0 (IRQ 3 (MODE +E)))
       #       (DMA 0 (CHANNEL 5))
       #       (DMA 1 (CHANNEL 6))
               (ACT Y)
       ))


  It also contains a few lines about overall configuration and about my
  sound card.  I found out after a bit of trial-and-error that the NI
  board does not always work with interrupts other than IRQ 3.  YMMV.
  Currently, the driver doesn't use DMA, but it may in the future, so I
  commented out the DMA lines.  It is a curious fact that the device
  ignores the IRQ and DMA information given here, however, I keep the
  information here to remind myself that the numbers aren't arbitrary.

  When I run comedi_config (as root, of course), I provide the same
  information.  Since I want to have the board configured every time I
  boot, I put the line



       /usr/sbin/comedi_config /dev/comedi0 atmio-E 0x260,3



  into /etc/rc.d/rc.local.  You can, of course, run this command at a
  command prompt.  The man page tells me that the option list is
  supposed to be "(I/O base),(IRQ)", so I used the same numbers as I put
  in /etc/isapnp.conf, i.e., 0x260,3.

  For the Data Translation board, I need to have a list of the jumper
  settings.  Fortunately, I wrote them all down in the manual -- I hope
  they are still correct.  However, I had to open the case to figure out
  which board in the series I had.  It is a DT2821-f-8di.  The man page
  of comedi_config tells me that I need to know the I/O base, IRQ, DMA
  1, DMA 2.  However, since I wrote the driver, I know that it also
  recognizes the differential/single-ended and unipolar/bipolar jumpers.
  As always, the source is the final authority, and looking in
  module/dt282x.c tells me that the options list is interpreted as:


  +o  I/O base

  +o  IRQ

  +o  1=differential, 0=single ended

  +o  ai 0=unipolar, 1=bipolar

  +o  ao0 0=unipolar, 1=bipolar

  +o  ao1 0=unipolar, 1=bipolar

  +o  dma1

  +o  dma2

  (ai=analog input, ao=analog output.)  From this, I decide that the
  appropriate options list is



       0x200,4,,1,1,1



  I left the differential/single-ended number blank, since the driver
  already knowns (from the board name), that it is differential.  I
  also left the DMA numbers blank, since I don't want the driver to use
  DMA.  (Don't want it to interfere with my sound card -- life is full
  of difficult choices.)  Keep in mind that things commented in the
  source, but not in the documentation are about as likely to change as
  the weather, so I put good comments next to the following line when I
  put it in rc.local.



       /usr/sbin/comedi_config /dev/comedi1 dt2821-f-8di 0x200,4,,1,1,1



  So now I think that I have my boards configured correctly.  Since data
  acquisition boards are not typically well-engineered, comedi sometimes
  can't figure out if the board is actually there.  If it can't, it
  assumes you are right.  Both of these boards are well-made, so comedi
  will give me an error message if it can't find them.  The comedi
  kernel module, since it is a part of the kernel, prints messages to
  the kernel logs, which you can access through the command 'dmesg' or
  /var/log/messages.  Here is a configuration failure (from dmesg):



       comedi0: ni_E: 0x0200 can't find board



  When it does work, I get:



       comedi0: ni_E: 0x0260 at-mio-16e-10 ( irq = 3 )



  Note that it also correctly identified my board.



  22..44..  GGeettttiinngg iinnffoorrmmaattiioonn ffrroomm ccoommeeddii



  So now that we have comedi talking to the hardware, we want to talk to
  comedi.  Here's some pretty low-level information -- it's sometimes
  useful for debugging:



       cat /proc/comedi



  Right now, on my computer, this command gives:



  comedi version 0.6.4
  format string
   0: atmio-E              at-mio-16e-10           7
   1: dt282x               dt2821-f-8di            4



  This is a feature that is not well-developed yet.  Basically, it
  currently tells you driver name, device name, and number of
  subdevices.

  In the demo/ directory, there is a command called info, which provides
  information about each subdevice on the board.  The output of it is
  rather long, since I have 7 subdevices  (4 or fewer is common for
  other boards.)  Here's part of the output of the NI board (which is on
  /dev/comedi0.)  ('demo/info /dev/comedi0')



       overall info:
         version code: 0x000604
         driver name: atmio-E
         board name: at-mio-16e-10
         number of subdevices: 7
       subdevice 0:
         type: 1 (unknown)
         number of channels: 16
         max data value: 4095


       ...


  The overall info gives information about the device -- basically the
  same information as /proc/comedi.

  This board has 7 subdevices.  Devices are separated into subdevices
  that each have a distinct purpose -- e.g., analog input, analog
  output, digital input/output.  This board also has an EEPROM and
  calibration DACs that are also subdevices.

  Subdevice 0 is the analog input subdevice.  You would have known this
  from the 'type: 1 (unknown)' line, if I've updated demo/info recently,
  because it would say 'type: 1 (analog input)' instead.  The other
  lines should be self-explanitory.  Comedi has more information about
  the device, but demo/info doesn't currently display this.



  33..  IInnddiivviidduuaall ddrriivveerrss


  This section contains information that is specific to each hardware
  driver.  The most current information about a driver is included in
  the comedi source.


  33..11..  NNaattiioonnaall IInnssttrruummeennttss AATT--MMIIOO EE sseerriieess



  33..22..  DDaattaa TTrraannssllaattiioonn



  44..  WWrriittiinngg pprrooggrraammss tthhaatt uussee ccoommeeddii aanndd ccoommeeddiilliibb



  44..11..  YYoouurr ffiirrsstt ccoommeeddii pprrooggrraamm


  This example requires a card that has analog or digital input.  Right
  to the source:



       #include <stdio.h>      /* for printf() */
       #include <comedilib.h>

       int subdev = 0;         /* change this to your input subdevice */
       int chan = 0;           /* change this to your channel */
       int range = 0;          /* more on this later */
       int aref = AREF_GROUND; /* more on this later */

       int main(int argc,char *argv[])
       {
               comedi_t *it;
               lsampl_t data;

               it=comedi_open("/dev/comedi0");

               comedi_data_read(it,subdev,chan,range,aref,&data);

               printf("%d\n",data);

               return 0;
       }



  Should be understandable: open the device, get the data, print it out.
  This is basically the guts of demo/inp.c, without error checking or
  fancy options.  Compile it using



       cc tut1.c -lcomedi -o tut1



  A few notes:  The range variable tells comedi which gain to use when
  measuring an analog voltage.  Since we don't know (yet) which numbers
  are valid, or what each means, we'll use 0, because it won't cause
  errors.  Likewise with aref, which determines the analog reference
  used.



  44..22..  CCoonnvveerrttiinngg ssaammpplleess ttoo vvoollttaaggeess


  If you selected an analog input subdevice, you probably noticed that
  the output of tut1 is a number between 0 and 4095, or 0 and 65535,
  depending on the number of bits in the A/D converter.  Comedi samples
  are aallwwaayyss unsigned, with 0 representing the lowest voltage of the
  ADC, and 4095 the highest.  Comedi compensates for anything else the
  manual for your device says.  However, you probably prefer to have
  this number translated to a voltage.  Naturally, as a good programmer,
  your first question is: "How do I do this in a device-independent
  manner?"

  Most devices give you a choice of gain and unipolar/bipolar input, and
  Comedi allows you to select which of these to use.  This parameter is
  called the "range parameter", since it specifies the "input range" for
  analog input (or "output range" for analog output.)  The range
  parameter represents both the gain and the unipolar/bipolar aspects.

  Comedi keeps the number of available ranges and the largest sample
  value for each subdevice/channel combination.  (Some devices allow
  different input/output ranges for different channels in a subdevice.)

  The largest sample value can be found using the function:

  comedi_get_maxdata()

  The number of available ranges can be found using the function:

  comedi_get_n_ranges()

  For each value of the range parameter for a particular
  subdevice/channel, you can get range information using the function:

  ptr=comedi_get_range(comedi_file,subdevice,channel, range)

  which returns a pointer to a comedi_range structure.  The comedi_range
  structure looks like



       typedef struct{
               double min;
               double max;
               unsigned int unit;
       }comedi_range;



  The structure element 'min' represents the voltage corresponding to
  comedi_data_read() returning 0, and 'max' represents
  comedi_data_read() returning 'maxdata', (i.e., 4095 for 12 bit A/C
  converters, 65535 for 16 bit, or, 1 for digital input -- more on this
  in a bit.)  The max refer to voltage, current, etc.

  "Could it get easier?", you say.  Well, yes.  Use the function
  comedi_to_phys(), which converts data values to physical units.  Call
  it using something like



       volts=comedi_to_phys(it,data,range,maxdata);


  and the opposite



       data=comedi_from_phys(it,volts,range,maxdata);



  44..33..  AAnnootthheerr sseeccttiioonn



  In addition to providing low level routines for data access, the
  comedi library provides higher-level access, much like the standard C
  library provides fopen(), etc.  as a high-level (and portable)
  alternative to the direct UNIX system calls open(), etc.  Similarily
  to fopen(), we have comedi_open():



       file=comedi_open("/dev/comedi0");



  where file is of type (comedi_t *).  This function calls open(), like
  we did explicitly in a previous section, but also fills the comedi_t
  structure with lots of goodies -- information that we will need to use
  soon.

  Specifically, we needed to know maxdata for a specific
  subdevice/channel.  How about:



       maxdata=comedi_get_maxdata(file,subdevice,channel);



  Wow.  How easy.  And the range type?



       range_type=comedi_get_rangetype(file,subdevice,channel);



  Cool.  Other information you need to know about a channel can be
  gotten in a similar way.



  44..44..  YYoouurr sseeccoonndd ccoommeeddii pprrooggrraamm



  Actually, this is the first comedi program again, just that we've
  added what we've learned.
       #include <stdio.h>      /* for printf() */
       #include <comedi.h>     /* also included by comedilib.h */
       #include <comedilib.h>  /* 'cuz we're using comedilib */

       int subdev = 0;         /* change this to your input subdevice */
       int chan = 0;           /* change this to your channel */
       int range = 0;          /* more on this later */
       int aref = 0;           /* more on this later */

       int main(int argc,char *argv[])
       {
               comedi_t *cf;
               int chan=0;
               lsampl_t data;
               int maxdata,rangetype;
               double volts;

               cf=comedi_open("/dev/comedi0");

               maxdata=comedi_get_maxdata(cf,subdev,chan);

               rangetype=comedi_get_rangetype(cf,subdev,chan);

               comedi_data_read(cf->fd,subdev,chan,range,aref,&data);

               volts=comedi_to_phys(data,rangetype,range,maxdata);

               printf("%d %g\n",data,volts);

               return 0;
       }



  55..  AApppplliiccaattiioonn--ssppeecciiffiicc ffuunnccttiioonnss



  55..11..  DDiiggiittaall IInnppuutt//OOuuttppuutt


  Many boards supported by comedi have digital input and output
  channels.  Some boards allow the direction of a channel to be
  specified in software.

  Comedi groups digital channels into subdevice, which is a group of
  digital channels that have the same characteristics.  For example,
  digital output lines will be grouped into a digital output subdevice,
  bidirectional digital lines will be grouped into a digital I/O
  subdevice.  Thus, there can be multiple digital subdevices on a
  particular board.

  Individual digital lines can be read and written using the functions

  comedi_dio_read(device,subdevice,channel,unsigned int *bit);
  comedi_dio_write(device,subdevice,channel,unsigned int bit);

  The direction of bidirectional lines can be configured using the
  function

  comedi_dio_config(device,subdevice,channel,unsigned int dir);

  The parameter dir should be either COMEDI_INPUT or COMEDI_OUTPUT.
  Many digital I/O subdevices group channels into blocks for configuring
  direction.  Changing one channel in a block changes the entire block.

  Multiple channels can be read and written simultaneously using the
  function

  comedi_dio_bitfield(device,subdevice,unsigned int write_mask,unsigned
  int *bits);

  Each channel is assigned to a bit in the write_mask and bits bitfield.
  If a bit in write_mask is set, the corresponding bit in *bits will be
  written to the corresponding digital output line.  Each digital line
  is then read and placed into *bits.  The value of bits in *bits
  corresponding to digital output lines is undefined and device-
  specific.  Channel 0 is the least significant bit in the bitfield;
  channel 31 is the most significant bit.  Channels higher than 31
  cannot be accessed using this method.



  55..22..  SSlloowwllyy--vvaarryyiinngg iinnppuuttss



  Sometimes, your input channels change slowly enough that you are able
  to average many sucessive input values to get a more accurate
  measurement of the actual value.  In general, the more samples you
  average, the better your estimate gets, roughly by a factor of
  sqrt(number_of_samples).  Obviously, there are limitations to this:



  +o  you are ultimately limited by "spurious free dynamic range"

  +o  you need to have _some_ noise on the input channel, otherwise you
     will be averaging the same number N times.

  +o  the more noise you have, the greater your SFDR, but it takes many
     more samples to compensate for the increased noise

  +o  if you feel the need to average samples for 2 seconds, your signal
     will need to be _very_ slowly-varying, i.e., not varying more than
     your target uncertainty for the entire 2 seconds.

  As you might have guessed, the comedi library has functions to help
  you in your quest to accurately measure slowly varying inputs.  I use
  these functions to measure thermocouple voltages -- actually, the
  library functions came from a section of code that was previously part
  of the thermocouple reading program.

  The comedi self-calibration utility also uses these functions.  On
  some hardware, it is possible to tell it to measure an internal stable
  voltage reference, which is typically going to be very slowly varying
  -- on the kilosecond time scale or more.  So it is reasonable to
  measure millions of samples, to get a very accurate measurement of the
  A/D converter output value that corresponds to the voltage reference.
  Sometimes, however, this is overkill, since there is no need to
  perform a part-per-million calibration to a standard that is only
  accurate to part-per-thousand.



  55..33..  CCoommmmaannddss



  Many data acquisition devices have the capability to directly control
  acquisition using either an on-board timer or an external triggering
  input.  Comedi commands are used to control this kind of acquisition.
  The ``comedi_cmd'' structure is used to control acquisition and query
  the capabilities of a device (see also ``comedi_command()'',
  ``comedi_command_test()'', and ``comedi_get_cmd_src_mask()'').

  Commands specify a particular data acquisition sequence, which is
  comprised of a number of scans.  Each scan is comprised of a number of
  conversions, which usually corresponds to a single A/D or D/A
  conversion.  The start and end of the sequence, and the start and end
  of each scan, and each conversion is called an event.

  Each of these 5 types of events are caused by a triggering source,
  specified through the *_src members of the ``comedi_cmd'' structure.
  The source types are:


  +o  TRIG_NONE:      don't ever cause an event

  +o  TRIG_NOW:       cause event to occur immediately

  +o  TRIG_FOLLOW:    see notes below

  +o  TRIG_TIME:      cause event to occur at a particular time

  +o  TRIG_TIMER:     cause event to occur repeatedly at a specific rate

  +o  TRIG_COUNT:     cause event when count reaches specific value

  +o  TRIG_EXT:       external signal causes event

  +o  TRIG_INT:       internal signal causes event

  +o  TRIG_OTHER:     driver-specific meaning

  Not all triggers are applicable to all events.  Supported triggers for
  specific events depend significantly on your particular device.  The
  ``comedi_get_cmd_src_mask()'' function is useful for determining what
  triggers a subdevice supports.

  For every trigger, there is a corresponding argument (the *_arg
  members of the ``comedi_cmd'' structure) whose meaning depends on the
  type of trigger.  The meanings of the arguments are as follows:

  TRIG_NONE is typically used only as a stop_src.  The argument for
  TRIG_NONE is reserved and should be set to 0.

  TRIG_NOW is most often used as a start_src.  The argument for TRIG_NOW
  is the number of nanoseconds between when the command is issued and
  when the event should occur.  In the case of using TRIG now as a
  start_src, it indicates a delay between issuing the command and the
  start of acquisition.  Most drivers only support a delay of 0.

  TRIG_FOLLOW is a special type of trigger for events that trigger on
  the completion of some other, logically connected event.  The argument
  is reserved and should be set to 0.  When used as a scan_begin_src, it
  indicates that a trigger should occur as a logical continuation of
  convert events.  This is done in order to properly describe boards
  that do not have separate timers for convert and scan_begin events.
  When used as a start_src for analog output subdevices, it indicates
  that conversion of output samples should begin when samples are
  written to the buffer.

  TRIG_TIME is reserved for future use.

  TRIG_TIMER is most often used as a convert_src, a scan_begin_src, or
  both.  It indicates that triggers should occur at a specific rate.
  The argument specifies the interval between triggers in nanoseconds.

  TRIG_COUNT is used for scan_end_src and stop_src.  It indicates that a
  trigger should occur when the specified number of corresponding lower-
  level triggers (convert and scan_begin, respectively) occur.  The
  argument is the count of lower-level triggers.

  TRIG_EXT can be useful as any of the trigger sources.  It indicates
  that an external digital line should be used to trigger the event.
  The exact meaning of digital line is device-dependent.  Some devices
  have one dedicated line, others may allow generic digital input lines
  to be used.  The argument indicates the particular external line to
  use as the trigger.

  TRIG_INT is typically used as a start_src.  This trigger occurs when
  the application performs an INSN_INTTRIG instruction.  Using TRIG_INT
  is a method by which the application can accurately record the time of
  the start of acquisition, since the parsing and setup time of a
  particular command may be significant.  The argument associated with
  TRIG_INT is reserved and should be set to 0.

  TRIG_OTHER can be useful as any of the trigger sources.  The exact
  meaning of TRIG_OTHER is driver-specific, and implements a feature
  that otherwise does not fit into the command interface.  Configuration
  of TRIG_OTHER features are done by INSN_CONFIG insns.  The argument is
  reserved and should be set to 0.

  Ths subdev member of the ``comedi_cmd'' structure is the index of the
  subdevice the command is intended for.  The
  ``comedi_find_subdevice_by_type()'' function can be useful in
  discovering the index of your desired subdevice.

  The chanlist member of the ``comedi_cmd'' structure should point to an
  array whose number of elements is specificed by chanlist_len (this
  will generally be the same as the scan_end_arg).  The chanlist
  specifies the sequence of channels and gains (and analog references)
  that should be stepped through for each scan.  The elements of the
  chanlist array should be initialized by packing the channel, range and
  reference information together with the ``CR_PACK()'' macro.

  The data and data_len members can be safely ignored when issueing
  commands from a user-space program.  They only have meaning when a
  command is sent from a kernel module using the kcomedilib interface,
  in which case they specify the buffer where the driver should
  write/read its data to/from.

  The final member of the ``comedi_cmd'' structure is flags.  The
  following flags are valid, and can be bitwise-or'd together.


  +o  TRIG_BOGUS:     do the motions??

  +o  TRIG_DITHER:    enable dithering??

  +o  TRIG_DEGLITCH:  enable deglitching??

  +o  TRIG_RT:        ask driver to use a hard real-time interrupt
     handler.  This will reduce latency in handling interrupts from your
     data aquisition hardware.  It can be useful if you are sampling at
     high frequency, or if your hardware has a small onboard fifo.  You
     must have a real-time kernel (RTAI or RTLinux) and must compile
     comedi with real-time support or this flag will do nothing.

  +o  TRIG_CONFIG:    perform configuration, not triggering.  This is a
     legacy of the deprecated comedi_trig_struct, and has no function at
     present.

  +o  TRIG_WAKE_EOS:  some drivers will change their behaviour when this
     flag is set, trying to transfer data at the end of every scan
     (instead of, for example, passing data in chunks whenever the
     board's onboard fifo is half full).  This flag may degrade a
     driver's performance at high frequencies.

  +o  TRIG_WRITE:     write to bidirectional devices.  Could be useful in
     principle, if someone wrote a driver that supported commands for a
     digital i/o device that could do either input or output.

     There are also a few flags that indicate how timing arguments
     should be rounded if the hardware cannot achieve the exact timing
     requested.

  +o  TRIG_ROUND_NEAREST: round to nearest supported timing period, the
     default.

  +o  TRIG_ROUND_DOWN: round period down.

  +o  TRIG_ROUND_UP: round period up.

  +o  TRIG_ROUND_UP_NEXT: this one doesn't do anything, and I don't know
     what it was intended to do??



  The typical sequence for executing a command is to first send the
  command through ``comedi_command_test()'' once or twice.  The test
  will check that the command is valid for the particular device, and
  often makes some adjustments to the command arguments, which can then
  be read back by the user to see the actual values used.  The command
  is executed with ``comedi_command()''.  For input/output commands,
  data is read from or written to the device file /dev/comedi[0..3] you
  are using.


  66..  LLiibbccoommeeddii RReeffeerreennccee



  66..11..  CCoonnssttaannttss aanndd MMaaccrrooss



  66..11..11..  CCRR__PPAACCKK(())


  CR_PACK(channel, range, aref)

  CR_PACK is used to initialize the elements of the chanlist array in
  the ``comedi_cmd'' structure, and the chanspec member of the
  ``comedi_insn'' structure.

  The channel argument is the channel you wish to use, with the channel
  numbering starting at zero.

  The range is an index, starting at zero, whose meaning is device
  dependent.  The ``comedi_get_n_ranges()'' and ``comedi_get_range()''
  functions are useful in discovering information about the available
  ranges.

  The aref argument indicates what reference you want the device to use.
  It can be any of the following:

  +o  AREF_GROUND     is for inputs/outputs referenced to ground

  +o  AREF_COMMON     is for a `common' reference (the low inputs of all
     the channels are tied together, but are isolated from ground)

  +o  AREF_DIFF       is for differential inputs/outputs

  +o  AREF_OTHER      is for any reference that does not fit into the
     above categories

     Particular drivers may or may not use the AREF flags.  If they are
     not supported, they are silently ignored.


  Source: /include/comedi.h



  66..11..22..  RRAANNGGEE__LLEENNGGTTHH(()) ((ddeepprreeccaatteedd))


  RANGE_LENGTH(rangetype)


  Rangetype values are library-internal tokens that represent an array
  of range information structures.  These numbers are primarily used for
  communication between the kernel and library.


  The RANGE_LENGTH() macro returns the length of the array that is
  specified by the rangetype token.


  The RANGE_LENGTH() macro is deprecated, and should not be used in new
  applications.  It is scheduled to be removed from the header file at
  version 1.0.  Binary compatibility may be broken for version 1.1.



  66..22..  DDaattaa TTyyppeess aanndd SSttrruuccttuurreess


  66..22..11..  ccoommeeddii__tt

  The data type comedi_t is used to represent an open Comedi device.  A
  valid comedi_t pointer is returned by a successful call to
  comedi_open(), and should be used for subsequent access to the device.
  It is a transparent type, and pointers to type comedi_t should not be
  dereferenced by the application.



  66..22..22..  ssaammppll__tt

  The data type sampl_t is one of the generic types used to represent
  data values in libcomedi.  It is used in a few places where a shorter
  data type is useful, but is limited to 16 bits on the i386
  architecture.

  66..22..33..  llssaammppll__tt

  The data type lsampl_t is one of the generic types used to represent
  data values in libcomedi.  It is currently defined to be unsigned int.



  66..22..44..  ccoommeeddii__ttrriigg__ssttrruucctt ((ddeepprreeccaatteedd))


  The comedi_trig structure



       struct comedi_trig_struct{
               unsigned int subdev;            /* subdevice */
               unsigned int mode;              /* mode */
               unsigned int flags;
               unsigned int n_chan;            /* number of channels */
               unsigned int *chanlist;         /* channel/range list */
               sampl_t *data;                  /* data list, size depends on subd flags */
               unsigned int n;                 /* number of scans */
               unsigned int trigsrc;
               unsigned int trigvar;
               unsigned int trigvar1;
               unsigned int data_len;
               unsigned int unused[3];
       }



  The comedi_trig structure is a control structure used by the
  COMEDI_TRIG ioctl, an older method of communicating instructions to
  the driver and hardware.  Use of comedi_trig is deprecated, and should
  not be used in new applications.


  This structure is defined as part of the Comedi kernel interface.



  66..22..55..  ccoommeeddii__ssvv__tt



       struct comedi_sv_struct{
               comedi_t *dev;
               unsigned int subdevice;
               unsigned int chan;

               /* range policy */
               int range;
               int aref;

               /* number of measurements to average (for ai) */
               int n;

               lsampl_t maxdata;
       }


  The comedi_sv_t structure is used by the comedi_sv_*() functions to
  provide a simple method of accurately measuring slowly varying inputs.
  See the relevant section for more details.



  66..22..66..  ccoommeeddii__ccmmdd



       typedef struct comedi_cmd_struct comedi_cmd;

       struct comedi_cmd_struct{
               unsigned int subdev;
               unsigned int flags;

               unsigned int start_src;
               unsigned int start_arg;

               unsigned int scan_begin_src;
               unsigned int scan_begin_arg;

               unsigned int convert_src;
               unsigned int convert_arg;

               unsigned int scan_end_src;
               unsigned int scan_end_arg;

               unsigned int stop_src;
               unsigned int stop_arg;

               unsigned int *chanlist;
               unsigned int chanlist_len;

               sampl_t *data;
               unsigned int data_len;
       };



  More information on using commands can be found in the ``command''
  section.


  This structure is defined as part of the Comedi kernel interface.



  66..22..77..  ccoommeeddii__iinnssnn


  undocumented


  Related functions are described in section XXX.


  This structure is defined as part of the Comedi kernel interface.



  66..22..88..  ccoommeeddii__rraannggee


  undocumented



  66..33..  FFuunnccttiioonnss



  66..33..11..  ccoommeeddii__cclloossee(())


  void comedi_close(comedi_t *it);


  Closes a device previously opened by comedi_open().


  The return type of this function will change to int, in order to match
  fclose.


  Source: /lib/comedi.c



  66..33..22..  ccoommeeddii__ccoommmmaanndd(())


  int comedi_command(comedi_t *it, comedi_cmd *cmd);

  Issues the command pointed at by cmd to the open device it.  It is
  usually necessary to pass the command through
  ``comedi_command_test()'' to fix up the command before it can be
  successfully executed with comedi_command().  See ``commands'' for
  more information.


  Source: /lib/comedi.c



  66..33..33..  ccoommeeddii__ccoommmmaanndd__tteesstt(())


  int comedi_command_test(comedi_t *it, comedi_cmd *cmd);


  Tests and fixes up the command pointed at by cmd according to the
  limitations of the driver configured on the open device it.  The
  return value has the following meaning:

  +o  0:      the command passed the test and can be successfully
     executed by ``comedi_command()''.  The one exception to this rule
     is that the test will allow a NULL chanlist for the command.

  +o  1: invalid trigger.  One or more of the trigger sources (the *_src
     members of the ``comedi_cmd'' structure) is not supported by the
     driver.

  +o  2: incompatible triggers.  Two or more of the triggers selected are
     incompatible with each other.  For example, a driver might allow
     either the scan_begin_src or the convert_src to be TRIG_TIMER, but
     not both.

  +o  3: argument invalid.  One or more argument is invalid, for example
     a timing argument might be in excess of the card's maximum speed.
     The command test will correct the arguments by modifying the
     command pointed at by cmd.

  +o  4: argument fix up.  The command underwent minor adjustment and
     should now be valid.  For example, a timing argument might not be
     exactly achievable by the card so the timing argument will be
     adjusted to the actual timing the card will use.

  +o  negative: some other error has occured.

     See ``commands'' for more information.


  Source: /lib/comedi.c



  66..33..44..  ccoommeeddii__ddaattaa__rreeaadd(())


  int comedi_data_read(comedi_t *it,unsigned int subd,unsigned int chan,
  unsigned int range,unsigned int aref,lsampl_t *data);


  Reads a single sample on the channel that is specified by the comedi
  device it, the subdevice subd, and the channel chan.  For the A/D
  conversion (if appropriate), the device is configured to use range
  specification range and (if appropriate) analog reference type aref.
  Analog reference types that are not supported by the device are
  silently ignored.


  comedi_data_read() reads one data value from the specified channel and
  places the data value that is read in the location pointed to by data.


  On sucess, comedi_data_read() returns 0.  If there is an error, -1 is
  returned.


  Valid analog reference numbers are:


  +o  AREF_GROUND     Reference to analog ground

  +o  AREF_COMMON     Reference to analog common

  +o  AREF_DIFF               Differential reference

  +o  AREF_OTHER      Board-specific meaning

  Valid data values returned by these function is an unsigned integer
  less than or equal to maxdata, which is channel-dependent.  Conversion
  of these data value to physical units can be performed by
  ``comedi_to_phys()''.

  Source: /lib/data.c



  66..33..55..  ccoommeeddii__ddaattaa__wwrriittee(())


  int comedi_data_write(comedi_t *it,unsigned int subd,unsigned int
  chan, unsigned int range,unsigned int aref,lsampl_t data);


  Writes a single sample on the channel that is specified by the comedi
  device it, the subdevice subd, and the channel chan.  For the D/A
  conversion (if appropriate), the device is configured to use range
  specification range and (if appropriate) analog reference type aref.
  Analog reference types that are not supported by the device are
  silently ignored.

  comedi_data_write() writes the data value specified by the argument
  data to the specified channel.

  On sucess, comedi_data_write() returns 0.  If there is an error, -1 is
  returned.

  Valid analog reference numbers are:


  +o  AREF_GROUND     Reference to analog ground

  +o  AREF_COMMON     Reference to analog common

  +o  AREF_DIFF               Differential reference

  +o  AREF_OTHER      Board-specific meaning

  Valid data values used by these functions is an unsigned integer less
  than or equal to maxdata, which is channel-dependent.  Conversion of
  physical units to these data value can be performed by
  ``comedi_from_phys()''.

  Source: /lib/data.c



  66..33..66..  ccoommeeddii__ddiioo__bbiittffiieelldd(());;

  int comedi_dio_bitfield(comedi_t *it,unsigned int subd,unsigned int
  write_mask,unsigned int *bits);


  The function comedi_dio_bitfield() allows multiple channels to be read
  simultaneously from a digital input or digital I/O device.  The
  parameter write_mask and the value pointed to by bits are interpreted
  as bit fields, with the least significant bit representing channel 0.
  For each bit in write_mask that is set, the cooresponding bit in *bits
  is written to the digital output channel.  Each digital input channel
  is read, and the result placed in the approprate bits in *bits.


  The current implementation reads and writes bits using separate system
  calls, which is not ideal.  When the kernel driver supports
  simultaneous reading/writing, this will be fixed in the library.


  It should be noted that it is not possible to access channels greater
  than 31 using this function.



  Source: /lib/dio.c



  66..33..77..  ccoommeeddii__ddiioo__ccoonnffiigg(())

  int comedi_dio_config(comedi_t *it,unsigned int subd,unsigned int
  chan,unsigned int dir);


  The function comedi_dio_config configures individual channels in a
  digital I/O subdevice to be either input or output, depending on the
  value of parameter dir.  Depending on the capabilities of the hardware
  device, multiple channels may be affected by a single call to
  comedi_dio_config.


  Valid directions are:

  +o  COMEDI_INPUT

  +o  COMEDI_OUTPUT

  Source: /lib/dio.c



  66..33..88..  ccoommeeddii__ddiioo__rreeaadd(())

  int comedi_dio_read(comedi_t *it,unsigned int subd,unsigned int
  chan,unsigned int *bit);


  The function reads the status of channel chan belonging to the digital
  input subdevice subd of device it. The result, 0 or 1, is stored in
  bit. Returns -1 on failure.


  This function is equivalent to comedi_data_read(it,subd,chan,0,0,bit).


  Source: /lib/dio.c



  66..33..99..  ccoommeeddii__ddiioo__wwrriittee(())

  int comedi_dio_write(comedi_t *it,unsigned int subd,unsigned int
  chan,unsigned int bit);


  The function writes the value of bit, 0 or 1, to channel chan,
  belonging to the digital output device subd of device it. Returns -1
  on failure.


  Source: /lib/dio.c



  66..33..1100..  ccoommeeddii__ffiilleennoo(())



  int comedi_fileno(comedi_t *it);


  The function comedi_fileno returns the integer descriptor for the
  handle it.  It is equivalent to the standard function fileno.  If it
  is an invalid comedi_t pointer, the function returns -1 and sets the
  appropriate libcomedi error value.

  Source: /lib/comedi.c



  66..33..1111..  ccoommeeddii__ffiinndd__rraannggee(())


  int comedi_find_range(comedi_t *it, unsigned int subdevice, unsigned
  int chan, unsigned int unit, double min, double max);


  The function comedi_find_range tries to locate the optimal (smallest)
  range for the channel chan belonging to a subdevice of the comedi
  device it, that includes both min and max in units.  If it finds a
  matching range, it returns its index.  If no matching range is
  available, it returns -1.


  Valid units are:


  +o  UNIT_volt

  +o  UNIT_mA

  +o  UNIT_none

  Source: /lib/range.c



  66..33..1122..  ccoommeeddii__eerrrrnnoo(())

  int comedi_errno(void);


  The function comedi_errno() returns an integer describing the most
  recent comedilib error.  This integer may be used as the errnum
  parameter for ``comedi_strerror()''.

  When a libcomedi function fails, it usually returns -1 or NULL,
  depending on the return type.  An internal library variable stores an
  error number, which can be retrieved with comedi_errno().  This error
  number can be converted to a human-readable form by the functions
  ``comedi_perror()'' and ``comedi_strerror()''.

  These functions are intended to mimic the behavior of the standard C
  library functions perror(), strerror, and errno().  In particular,
  libcomedi functions sometimes return an error that is generated by the
  C library; the Comedi error message in this case is the same as the C
  library.

  Source: /lib/error.c



  66..33..1133..  ccoommeeddii__ffiinndd__ssuubbddeevviiccee__bbyy__ttyyppee(())


  int comedi_find_subdevice_by_type(comedi_t *it,int type,unsigned int
  start_subdevice);


  The function comedi_find_subdevice_by_type tries to locate a subdevice
  belonging to comedi device it, having type type, starting with the
  subdevice start_subdevice.  If it finds the requested subdevice, it
  returns its index.  If it does not locate the requested subdevice, it
  returns -1 and sets the comedi error number to "subdevice not found".
  If there is an error, the function returns -1 and sets the appropriate
  error.


  For subdevice types, see the manual page for the function
  ``comedi_get_subdevice_type()''.

  Source: /lib/get.c



  66..33..1144..  ccoommeeddii__ffrroomm__pphhyyss(())


  lsampl_t comedi_from_phys(double data, comedi_range *rng, lsampl_t
  maxdata);

  Converts data given in physical units (data) into sample values
  (lsampl_t, between 0 and maxdata).  The parameter rng represents the
  conversion information to use, and the parameter maxdata represents
  the maximum possible data value for the channel that the data will be
  written to.


  Source: /lib/range.c



  66..33..1155..  ccoommeeddii__ggeett__bbooaarrdd__nnaammee(())


  char *comedi_get_board_name(comedi_t *it);

  The function comedi_get_board_name returns a pointer to a string
  containing the name of the device.  This pointer is valid until the
  comedi descriptor it is closed.  This function returns NULL if there
  is an error.

  Source: /lib/get.c



  66..33..1166..  ccoommeeddii__ggeett__ccmmdd__ssrrcc__mmaasskk(())


  int comedi_get_cmd_src_mask(comedi_t *dev, unsigned int subdevice,
  comedi_cmd *cmd);

  undocumented

  Source: /lib/cmd.c

  66..33..1177..  ccoommeeddii__ggeett__ddrriivveerr__nnaammee(())


  char *comedi_get_driver_name(comedi_t *it);

  The function comedi_get_driver_name returns a pointer to a string
  containing the name of the driver being used by comedi for the comedi
  device represented by it.  This pointer is valid until the comedi
  descriptor it is closed.  This function returns NULL if there is an
  error.

  Source: /lib/get.c



  66..33..1188..  ccoommeeddii__ggeett__mmaaxxddaattaa(())


  lsampl_t comedi_get_maxdata(comedi_t *it,unsigned int
  subdevice,unsigned int chan);


  The function comedi_get_maxdata() returns the maximum valid data value
  for channel chan of subdevice subdevice belonging to the comedi device
  it This function returns 0 on error.

  Source: /lib/get.c



  66..33..1199..  ccoommeeddii__ggeett__nn__cchhaannnneellss(())


  int comedi_get_n_channels(comedi_t *it,unsigned int subdevice);

  The function comedi_get_n_channels() returns the number of channels of
  the subdevice belonging to the comedi device it and having index
  subdevice.  This function returns -1 on error.

  Source: /lib/get.c



  66..33..2200..  ccoommeeddii__ggeett__nn__rraannggeess(())


  int comedi_get_n_ranges(comedi_t *it,unsigned int subdevice, unsigned
  int chan);

  The function comedi_get_n_ranges() returns the number of ranges of the
  channel chan belonging to the subdevice of the comedi device it.  This
  function returns -1 on error.

  Source: /lib/range.c



  66..33..2211..  ccoommeeddii__ggeett__nn__ssuubbddeevviicceess(())


  int comedi_get_n_subdevices(comedi_t *it);

  The function comedi_get_n_subdevices returns the number of subdevices
  associated with the comedi descriptor it, or -1 if there is an error.

  Source: /lib/get.c



  66..33..2222..  ccoommeeddii__ggeett__rraannggee(())


  comedi_range * comedi_get_range(comedi_t *it,unsigned int
  subdevice,unsigned int chan,unsigned int range);

  The function comedi_get_range returns a pointer to a comedi_range
  structure that contains information that can be used to convert sample
  values to or from physical units.  The pointer is valid until the
  comedi device it is closed.  If there is an error, NULL is returned.

  Source: /lib/get.c



  66..33..2233..  ccoommeeddii__ggeett__rraannggeettyyppee(())  ddeepprreeccaatteedd


  int comedi_get_rangetype(comedi_t *it,unsigned int subdevice,unsigned
  int chan);

  The function comedi_get_rangetype() returns an integer that represents
  the number of range specifications available for a particular channel
  chan of the subdevice subdevice, as well as a conversion table to
  convert sample values to/from physical units.

  The macro RANGE_LENGTH(rangetype) can be used to determine the number
  of range specifications for a given range type.


  This function is deprecated and should not be used in new code.

  Source: /lib/get.c



  66..33..2244..  ccoommeeddii__ggeett__ssuubbddeevviiccee__ttyyppee(())


  int comedi_get_subdevice_type(comedi_t *it,unsigned int subdevice);

  The function comedi_get_subdevice_type() returns an integer describing
  the type of subdevice that belongs to the comedi device it and has the
  index subdevice.  The function returns -1 is there is an error.

  Valid subdevice types are:


  +o  COMEDI_SUBD_UNUSED Subdevice has no functionality, i.e., a place-
     holder.

  +o  COMEDI_SUBD_AI    Analog input

  +o  COMEDI_SUBD_AO    Analog output

  +o  COMEDI_SUBD_DI    Digital input


  +o  COMEDI_SUBD_DO    Digital output

  +o  COMEDI_SUBD_DIO Digital input/output.  Channels are configurable as
     to whether they are inputs or outputs.

  +o  COMEDI_SUBD_COUNTER       Counter

  +o  COMEDI_SUBD_TIMER Timer

  +o  COMEDI_SUBD_MEMORY Memory, e.g., EEPROM or dual-ported RAM

  +o  COMEDI_SUBD_CALIB Calibration DACs

  +o  COMEDI_SUBD_PROC Processor or DSP

  Source: /lib/get.c



  66..33..2255..  ccoommeeddii__ggeett__ttiimmeerr(()) ((ddeepprreeccaatteedd))


  int comedi_get_timer(comedi_t *it,unsigned int subdev, double
  freq,unsigned int *trigvar, double *actual_freq);


  The function comedi_get_timer converts the frequency freq to a number
  suitable to send to the driver in a comedi_trig structure.  This
  function remains for compatibility with very old versions of Comedi,
  that converted sampling rates to timer values in the libary.  This
  conversion is now done in the kernel, and every device has the timer
  type nanosec_timer, indicating that timer values are simply a time
  specified in nanoseconds.


  This function is deprecated and should not be used in new
  applications.


  Source: /lib/timer.c



  66..33..2266..  ccoommeeddii__ggeett__vveerrssiioonn__ccooddee(())


  int comedi_get_version_code(comedi_t *it);


  The function comedi_get_version_code() returns the version code of the
  currently running comedi module.  The version code is of the form
  0x01072b, which is the version code for version 1.7.43.


  This function is of limited usefulness.  A typical mis-application of
  this function is to use it to determine if a certain feature is
  supported.  If the application needs to know of the existence of a
  particular feature, an existence test function should be written and
  put in the libcomedi source.

  Source: /lib/get.c



  66..33..2277..  ccoommeeddii__lloogglleevveell(())


  int comedi_loglevel(int loglevel);


  This function affects the output of debugging and error messages from
  libcomedi.  By increasing the loglevel, additional debugging
  information will be printed.  This function returns the previous
  loglevel.  Error messages and debugging are printed to the stream
  stderr.  The loglevel can also be affected by the environment variable
  COMEDI_LOGLEVEL.


  In order to conserve resources, some debugging information is disabled
  when libcomedi is compiled.


  The meaning of the loglevels is as follows:


  +o  COMEDILIB_LOGLEVEL=0

     Comedilib prints nothing.

  +o  COMEDILIB_LOGLEVEL=1  (default)

     Comedilib only prints error messages when there is a self-
     consistency error (i.e., internal bug).

  +o  COMEDILIB_LOGLEVEL=2

     Comedilib prints an error message when an invalid parameter is
     passed to comedilib.

  +o  COMEDILIB_LOGLEVEL=3

     Comedilib prints an error message whenever an error is generated in
     the comedilib library or is generated in the C library when called
     by comedilib.

  +o  COMEDILIB_LOGLEVEL=4

     Comedilib prints a lot of debugging messages.

  Bugs: Libcomedi doesn't currently have much debugging information.

  Source: /lib/error.c



  66..33..2288..  ccoommeeddii__ooppeenn(())


  comedi_t *comedi_open(char *filename);

  Opens a comedi device specified by the filename filename.  Returns
  NULL on error.  On sucess, it returns a handle that is given as a
  parameter to other libcomedi functions.


  You are not supposed to have access to the internals of the comedi_t
  structure.

  Bugs: Not strictly identical to fopen

  Source: /lib/comedi.c



  66..33..2299..  ccoommeeddii__ppeerrrroorr(())


  void comedi_perror(const char *s);

  When a comedilib function fails, it usually returns -1 or NULL,
  depending on the return type.  An internal library variable stores an
  error number, which can be retrieved with ``comedi_errno()''.  This
  error number can be converted to a human-readable form by the
  functions comedi_perror() and ``comedi_strerror()''.

  These functions are intended to mimic the behavior of the standard C
  library functions perror(), strerror, and errno().  In particular,
  comedilib functions sometimes return an error that is generated inside
  the C library; the comedi error message in this case is the same as
  the C library.

  The function comedi_perror() prints an error message to stderr.  The
  error message consists of the argument string, a colon, a space, a
  description of the error condition, and a new line.

  Bugs: Does not support internationalization.

  Source: /lib/error.c



  66..33..3300..  ccoommeeddii__ssttrreerrrroorr(())


  *comedi_strerror(int errnum);

  When a comedilib function fails, it usually returns -1 or NULL,
  depending on the return type.  An internal library variable stores an
  error number, which can be retrieved with ``comedi_errno()''.  This
  error number can be converted to a human-readable form by the
  functions ``comedi_perror()'' and comedi_strerror().

  These functions are intended to mimic the behavior of the standard C
  library functions perror(), strerror, and errno().  In particular,
  comedilib functions sometimes return an error that is generated inside
  the C library; the comedi error message in this case is the same as
  the C library.

  The function comedi_strerror() returns a pointer to a character string
  describing the comedilib error errnum.  The persistence of the
  returned pointer is undefined, and should not be trusted after the
  next libcomedi call.  An unrecognized error number will return a
  pointer to the string "undefined error", or similar.

  Bugs: Does not support internationalization.

  Source: /lib/error.c



  66..33..3311..  ccoommeeddii__ssvv__iinniitt(())


  int comedi_sv_init(comedi_sv_t *sv,comedi_t *dev,unsigned int subd,
  unsigned int chan);


  comedi_sv_init initializes the slow varying comedi structure sv of the
  device dev, the subdevice subd (analog input) and the channel chan.
  The slow varying comedi structure sv of type ``comedi_sv_t'' specifies
  the signal measurement.  The default number of averaged samples is
  100.  Returns zero on success, -1 on error.

  Bugs: comedi_sv_* was very poorly designed.

  Source: /lib/sv.c



  66..33..3322..  ccoommeeddii__ssvv__uuppddaattee(())


  int comedi_sv_update(comedi_sv_t *sv);

  The function comedi_sv_update updates the slow varying comedi
  structure sv.  Returns zero on success, -1 on error.

  Source: /lib/sv.c



  66..33..3333..  iinntt ccoommeeddii__ssvv__mmeeaassuurree(())


  int comedi_sv_measure(comedi_sv_t *it,double *data);

  comedi_sv_measure measures the slow variing signal. The measurement is
  specified by the slow varying comedi structure sv, the result is
  stored in data.  On success returns the number of samples, -1 on
  error.

  Source: /lib/sv.c



  66..33..3344..  ccoommeeddii__ttoo__pphhyyss(())


  double comedi_to_phys(lsampl_t data, comedi_range *rng, lsampl_t
  maxdata);

  Converts data given in sample values (lsampl_t, between 0 and maxdata)
  into physical units (double).  The parameter rng represents the
  conversion information to use, and the parameter maxdata represents
  the maximum possible data value for the channel that the data was
  read.

  Source: /lib/range.c



  66..33..3355..  ccoommeeddii__ttrriiggggeerr(()) ((ddeepprreeccaatteedd))


  int comedi_trigger(comedi_t *it,comedi_trig *trig);

  The function comedi_trigger instructs comedi to perform the command
  specified by the ``trigger structure'' trig.  Results depend on the
  particular command being issued.  If there is an error, -1 is
  returned.

  Lifetime: removal at 1.0.

  Source: /lib/comedi.c



  66..33..3366..  ccoommeeddii__ggeett__ssuubbddeevviiccee__ffllaaggss(())


  int comedi_get_subdevice_flags(comedi_t *dev, unsigned int subdevice);


  This function returns a bitfield describing the capabilities of the
  specified subdevice.  If there is an error, -1 is returned.


  The bits are:


  +o  SDF_BUSY                subdevice is running a command

  +o  SDF_BUSY_OWNER  subdevice is running a command started by the file
     descriptor used by dev.

  +o  SDF_LOCKED      subdevice is locked

  +o  SDF_LOCKED_OWNER        subdevice is locked by the file descriptor
     used by dev.

  +o  SDF_MAXDATA     maximum data values are channel dependent

  +o  SDF_FLAGS               channel flags are channel dependent

  +o  SDF_RANGETYPE   range types are channel dependent

  +o  SDF_MODE0               deprecated

  +o  SDF_MODE1               deprecated

  +o  SDF_MODE2               deprecated

  +o  SDF_MODE3               deprecated

  +o  SDF_MODE4               deprecated

  +o  SDF_CMD         subdevice supports commands

  +o  SDF_READABLE    subdevice can be read from

  +o  SDF_WRITEABLE   subdevice can be written to

  +o  SDF_RT          deprecated

  +o  SDF_GROUND      subdevice is capable of ground analog reference

  +o  SDF_COMMON      subdevice is capable of common analog reference

  +o  SDF_DIFF                subdevice is capable of differential analog
     reference

  +o  SDF_OTHER               subdevice is capable of other analog
     reference

  +o  SDF_DITHER      subdevice recognizes dither flag

  +o  SDF_DEGLITCH    subdevice recognizes deglitch flag

  +o  SDF_MMAP                deprecated

  +o  SDF_RUNNING     subdevice is acquiring data (i.e., command has not
     completed)

  +o  SDF_LSAMPL      subdevice uses samples of type lsampl_t (otherwise
     sampl_t)

  +o  SDF_PACKED      subdevice uses bitfield samples (otherwise it uses
     one sample per channel)



  The bit definitions are part of the Comedi kernel interface.



  66..33..3377..  ccoommeeddii__rraannggee__iiss__cchhaann__ssppeecciiffiicc(())


  int comedi_range_is_chan_specific(comedi_t *dev,unsigned int
  subdevice);


  If each channel of the specified subdevice has a different range
  specification, this function returns 1.  Otherwise, this function
  returns 0.  On error, this function returns -1.



  66..33..3388..  UUnnddooccuummeenntteedd ffuunnccttiioonnss



  +o  comedi_maxdata_is_chan_specific()

  +o  comedi_get_buffer_size()

  +o  comedi_get_max_buffer_size()

  +o  comedi_set_buffer_size()

  +o  comedi_set_max_buffer_size()

  +o  comedi_do_insnlist()

  +o  comedi_do_insn()

  +o  comedi_lock()

  +o  comedi_unlock()

  +o  comedi_get_cmd_src_mask()

  +o  comedi_get_cmd_generic_timed()

  +o  comedi_cancel()

  +o  comedi_poll()

  +o  comedi_get_buffer_contents()

  +o  comedi_mark_buffer_read()

  +o  comedi_get_buffer_offset()

  +o  comedi_set_global_oor_behavior()



