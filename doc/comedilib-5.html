<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.8.1">
 <TITLE>Comedi Documentation: Application-specific functions</TITLE>
 <LINK HREF="comedilib-6.html" REL=next>
 <LINK HREF="comedilib-4.html" REL=previous>
 <LINK HREF="comedilib.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="comedilib-6.html">Next</A>
<A HREF="comedilib-4.html">Previous</A>
<A HREF="comedilib.html#toc5">Contents</A>
<HR>
<H2><A NAME="s5">5.</A> <A HREF="comedilib.html#toc5">Application-specific functions</A></H2>



<H2><A NAME="ss5.1">5.1 Digital Input/Output</A>
</H2>


<P>Many boards supported by comedi have digital input and output
channels.  Some boards allow the direction of a channel to be
specified in software.</P>
<P>Comedi groups digital channels into subdevice, which is a group
of digital channels that have the same characteristics.  For
example, digital output lines will be grouped into a digital
output subdevice, bidirectional digital lines will be grouped
into a digital I/O subdevice.  Thus, there can be multiple
digital subdevices on a particular board.</P>
<P>Individual digital lines can be read and written using the
functions</P>
<P><CODE>comedi_dio_read(device,subdevice,channel,unsigned int *bit);</CODE>
<CODE>comedi_dio_write(device,subdevice,channel,unsigned int bit);</CODE></P>
<P>The direction of bidirectional lines can be configured using
the function</P>
<P><CODE>comedi_dio_config(device,subdevice,channel,unsigned int dir);</CODE></P>
<P>The parameter <CODE>dir</CODE> should be either COMEDI_INPUT or COMEDI_OUTPUT.
Many digital I/O subdevices group channels into blocks for
configuring direction.  Changing one channel in a block changes
the entire block.</P>
<P>Multiple channels can be read and written simultaneously using the
function</P>
<P><CODE>comedi_dio_bitfield(device,subdevice,unsigned int write_mask,unsigned int *bits);</CODE></P>
<P>Each channel is assigned to a bit in the <CODE>write_mask</CODE> and <CODE>bits</CODE>
bitfield.  If a bit in <CODE>write_mask</CODE> is set, the corresponding bit
in <CODE>*bits</CODE> will be written to the corresponding digital output line.
Each digital line is then read and placed into <CODE>*bits</CODE>.  The value
of bits in <CODE>*bits</CODE> corresponding to digital output lines is
undefined and device-specific.  Channel 0 is the least significant
bit in the bitfield; channel 31 is the most significant bit.  Channels
higher than 31 cannot be accessed using this method.</P>



<H2><A NAME="ss5.2">5.2 Slowly-varying inputs</A>
</H2>



<P>Sometimes, your input channels change slowly enough that
you are able to average many sucessive input values to get a
more accurate measurement of the actual value.  In general,
the more samples you average, the better your estimate
gets, roughly by a factor of sqrt(number_of_samples).
Obviously, there are limitations to this:</P>

<P>
<UL>
<LI>you are ultimately limited by "spurious free dynamic range"
</LI>
<LI>you need to have _some_ noise on the input channel,
otherwise you will be averaging the same number N times.
</LI>
<LI>the more noise you have, the greater your SFDR, but it
takes many more samples to compensate for the increased
noise
</LI>
<LI>if you feel the need to average samples for 2 seconds,
your signal will need to be _very_ slowly-varying, i.e.,
not varying more than your target uncertainty for the
entire 2 seconds.
</LI>
</UL>
</P>
<P>As you might have guessed, the comedi library has functions
to help you in your quest to accurately measure slowly varying
inputs.  I use these functions to measure thermocouple voltages
-- actually, the library functions came from a section of code
that was previously part of the thermocouple reading program.</P>
<P>The comedi self-calibration utility also uses these functions.
On some hardware, it is possible to tell it to measure an
internal stable voltage reference, which is typically going
to be very slowly varying -- on the kilosecond time scale
or more.  So it is reasonable to measure millions of samples,
to get a very accurate measurement of the A/D converter output
value that corresponds to the voltage reference.  Sometimes,
however, this is overkill, since there is no need to
perform a part-per-million calibration to a standard that
is only accurate to part-per-thousand.</P>



<H2><A NAME="command_section"></A> <A NAME="ss5.3">5.3 Commands</A>
</H2>



<P>Many data acquisition devices have the capability to directly
control acquisition using either an on-board timer or an external
triggering input.  Comedi commands are used to control this kind
of acquisition.  The 
<A HREF="comedilib-6.html#comedi_cmd">comedi_cmd</A> structure is
used to control acquisition and query the capabilities of a device
(see also 
<A HREF="comedilib-6.html#comedi_command">comedi_command()</A>,
<A HREF="comedilib-6.html#comedi_command_test">comedi_command_test()</A>, and
<A HREF="comedilib-6.html#comedi_get_cmd_src_mask">comedi_get_cmd_src_mask()</A>).</P>
<P>Commands specify a particular data acquisition sequence, which
is comprised of a number of scans.  Each scan is comprised of
a number of conversions, which usually corresponds to a single
A/D or D/A conversion.  The start and end of the sequence, and
the start and end of each scan, and each conversion is called an
event.</P>
<P>Each of these 5 types of events are caused by a triggering
source, specified through the <CODE>*_src</CODE> members of the
<A HREF="comedilib-6.html#comedi_cmd">comedi_cmd</A> structure.  The source types are:</P>
<P>
<UL>
<LI>TRIG_NONE:  don't ever cause an event</LI>
<LI>TRIG_NOW:   cause event to occur immediately</LI>
<LI>TRIG_FOLLOW:        see notes below</LI>
<LI>TRIG_TIME:  cause event to occur at a particular time</LI>
<LI>TRIG_TIMER: cause event to occur repeatedly at a specific rate</LI>
<LI>TRIG_COUNT: cause event when count reaches specific value</LI>
<LI>TRIG_EXT:   external signal causes event</LI>
<LI>TRIG_INT:   internal signal causes event</LI>
<LI>TRIG_OTHER: driver-specific meaning</LI>
</UL>
</P>
<P>Not all triggers are applicable to all events.  Supported triggers
for specific events depend significantly on your particular
device.  The 
<A HREF="comedilib-6.html#comedi_get_cmd_src_mask">comedi_get_cmd_src_mask()</A>
function is useful for determining what triggers a subdevice supports.</P>
<P>For every trigger, there is a corresponding
argument (the <CODE>*_arg</CODE> members of the 
<A HREF="comedilib-6.html#comedi_cmd">comedi_cmd</A>
structure) whose meaning depends on the type of trigger.  The meanings
of the arguments are as follows:</P>
<P>TRIG_NONE is typically used only as a <CODE>stop_src</CODE>.  The argument for TRIG_NONE
is reserved and should be set to 0.</P>
<P>TRIG_NOW is most often used as a <CODE>start_src</CODE>.  The argument for TRIG_NOW is
the number of nanoseconds between when the command is issued and when
the event should occur.  In the case of using TRIG now as a <CODE>start_src</CODE>,
it indicates a delay between issuing the command and the start of
acquisition.  Most drivers only support a delay of 0.</P>
<P>TRIG_FOLLOW is a special type of trigger for events that trigger on
the completion of some other, logically connected event.  The argument
is reserved and should be set to 0.  When used
as a <CODE>scan_begin_src</CODE>, it indicates that a trigger should occur as a
logical continuation of convert events.  This is done in order to
properly describe boards that do not have separate timers for
convert and scan_begin events.  When used as a <CODE>start_src</CODE> for analog
output subdevices, it indicates that conversion of output samples
should begin when samples are written to the buffer.</P>
<P>TRIG_TIME is reserved for future use.</P>
<P>TRIG_TIMER is most often used as a <CODE>convert_src</CODE>, a <CODE>scan_begin_src</CODE>, or
both.  It indicates that triggers should occur at a specific rate.
The argument specifies the interval between triggers in nanoseconds.</P>
<P>TRIG_COUNT is used for <CODE>scan_end_src</CODE> and <CODE>stop_src</CODE>.  It indicates that
a trigger should occur when the specified number of corresponding
lower-level triggers (convert and scan_begin, respectively) occur.
The argument is the count of lower-level triggers.</P>
<P>TRIG_EXT can be useful as any of the trigger sources.  It indicates
that an external digital line should be used to trigger the event.
The exact meaning of digital line is device-dependent.  Some devices
have one dedicated line, others may allow generic digital input
lines to be used.  The argument indicates the particular external
line to use as the trigger.</P>
<P>TRIG_INT is typically used as a <CODE>start_src</CODE>.  This trigger occurs when
the application performs an INSN_INTTRIG instruction.  Using TRIG_INT
is a method by which the application can accurately record the time of
the start of acquisition, since the parsing and setup time of a
particular command may be significant.  The argument associated with
TRIG_INT is reserved and should be set to 0.</P>
<P>TRIG_OTHER can be useful as any of the trigger sources.  The exact
meaning of TRIG_OTHER is driver-specific, and implements a feature
that otherwise does not fit into the command interface.  Configuration
of TRIG_OTHER features are done by INSN_CONFIG insns.  The argument
is reserved and should be set to 0.</P>
<P>Ths <CODE>subdev</CODE> member of the 
<A HREF="comedilib-6.html#comedi_cmd">comedi_cmd</A>
structure is the index of the subdevice the command is intended for.  The
<A HREF="comedilib-6.html#comedi_find_subdevice_by_type">comedi_find_subdevice_by_type()</A>
function can be useful in discovering the index of your desired subdevice.</P>
<P>The <CODE>chanlist</CODE> member of the 
<A HREF="comedilib-6.html#comedi_cmd">comedi_cmd</A>
structure should point to an array whose number of elements is specificed by <CODE>chanlist_len</CODE>
(this will generally be the same as the scan_end_arg).
The chanlist specifies the sequence of channels and gains (and analog references)
that should be stepped through for each scan.  The elements of the chanlist array
should be initialized by packing the channel, range and reference information
together with the 
<A HREF="comedilib-6.html#CR_PACK">CR_PACK()</A> macro.</P>
<P>The <CODE>data</CODE> and <CODE>data_len</CODE> members can be safely ignored when issueing commands
from a user-space program.  They only have meaning when a command is sent from a kernel
module using the kcomedilib interface, in which case they specify the buffer where
the driver should write/read its data to/from.</P>
<P>The final member of the 
<A HREF="comedilib-6.html#comedi_cmd">comedi_cmd</A> structure is <CODE>flags</CODE>.
The following flags are valid, and can be bitwise-or'd together.</P>
<P>
<UL>
<LI>TRIG_BOGUS: do the motions??</LI>
<LI>TRIG_DITHER:        enable dithering??</LI>
<LI>TRIG_DEGLITCH:      enable deglitching??</LI>
<LI>TRIG_RT:    ask driver to use a hard real-time interrupt handler.  This will
reduce latency in handling interrupts from your data aquisition hardware.  It can
be useful if you are sampling at high frequency, or if your hardware has a small onboard
fifo.  You must have a real-time kernel (RTAI or RTLinux) and must compile
comedi with real-time support or this flag will do nothing.</LI>
<LI>TRIG_CONFIG:        perform configuration, not triggering.  This is a legacy of the
deprecated comedi_trig_struct, and has no function at present.</LI>
<LI>TRIG_WAKE_EOS:      some drivers will change their behaviour when this flag is set,
trying to transfer data at the end of every scan (instead of, for example, passing
data in chunks whenever the board's onboard fifo is half full).  This flag
may degrade a driver's performance at high frequencies.</LI>
<LI>TRIG_WRITE: write to bidirectional devices.  Could be useful in principle, if someone
wrote a driver that supported commands for a digital i/o device that could do either
input or output.</LI>
</UL>

There are also a few flags that indicate how timing arguments should be rounded
if the hardware cannot achieve the exact timing requested.
<UL>
<LI>TRIG_ROUND_NEAREST: round to nearest supported timing period, the default.</LI>
<LI>TRIG_ROUND_DOWN: round period down.</LI>
<LI>TRIG_ROUND_UP: round period up.</LI>
<LI>TRIG_ROUND_UP_NEXT: this one doesn't do anything, and I don't know what it was intended
to do??</LI>
</UL>
</P>


<P>The typical sequence for executing a command is to first send
the command through
<A HREF="comedilib-6.html#comedi_command_test">comedi_command_test()</A>
once or twice.  The test will check that the command is valid for the particular
device, and often makes some adjustments to the command arguments, which
can then be read back by the user to see the actual values used.  The
command is executed with
<A HREF="comedilib-6.html#comedi_command">comedi_command()</A>.  For input/output commands, data
is read from or written to the device file /dev/comedi[0..3] you are using.</P>

<HR>
<A HREF="comedilib-6.html">Next</A>
<A HREF="comedilib-4.html">Previous</A>
<A HREF="comedilib.html#toc5">Contents</A>
</BODY>
</HTML>
