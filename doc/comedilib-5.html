<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.7.4">
 <TITLE>Comedi Documentation: Application-specific functions</TITLE>
 <LINK HREF="comedilib-4.html" REL=previous>
 <LINK HREF="comedilib.html#toc5" REL=contents>
</HEAD>
<BODY>
Next
<A HREF="comedilib-4.html">Previous</A>
<A HREF="comedilib.html#toc5">Contents</A>
<HR>
<H2><A NAME="s5">5.</A> <A HREF="comedilib.html#toc5">Application-specific functions</A></H2>



<H2><A NAME="ss5.1">5.1 Digital Input/Output</A>
</H2>


<P>Many boards supported by comedi have digital input and output
channels.  Some boards allow the direction of a channel to be
specified in software.</P>
<P>Comedi groups digital channels into subdevice, which is a group
of digital channels that have the same characteristics.  For
example, digital output lines will be grouped into a digital
output subdevice, bidirectional digital lines will be grouped
into a digital I/O subdevice.  Thus, there can be multiple
digital subdevices on a particular board.</P>
<P>Individual digital lines can be read and written using the
functions</P>
<P><CODE>comedi_dio_read(device,subdevice,channel,unsigned int *bit);</CODE>
<CODE>comedi_dio_write(device,subdevice,channel,unsigned int bit);</CODE></P>
<P>The direction of bidirectional lines can be configured using
the function</P>
<P><CODE>comedi_dio_config(device,subdevice,channel,unsigned int dir);</CODE></P>
<P>The parameter <CODE>dir</CODE> should be either COMEDI_INPUT or COMEDI_OUTPUT.
Many digital I/O subdevices group channels into blocks for
configuring direction.  Changing one channel in a block changes
the entire block.</P>
<P>Multiple channels can be read and written simultaneously using the
function</P>
<P><CODE>comedi_dio_bitfield(device,subdevice,unsigned int write_mask,unsigned int *bits);</CODE></P>
<P>Each channel is assigned to a bit in the <CODE>write_mask</CODE> and <CODE>bits</CODE>
bitfield.  If a bit in <CODE>write_mask</CODE> is set, the corresponding bit
in <CODE>*bits</CODE> will be written to the corresponding digital output line.
Each digital line is then read and placed into <CODE>*bits</CODE>.  The value
of bits in <CODE>*bits</CODE> corresponding to digital output lines is
undefined and device-specific.  Channel 0 is the least significant
bit in the bitfield; channel 31 is the most significant bit.  Channels
higher than 31 cannot be accessed using this method.</P>



<H2><A NAME="ss5.2">5.2 Slowly-varying inputs</A>
</H2>



<P>Sometimes, your input channels change slowly enough that
you are able to average many sucessive input values to get a
more accurate measurement of the actual value.  In general,
the more samples you average, the better your estimate
gets, roughly by a factor of sqrt(number_of_samples).
Obviously, there are limitations to this:</P>

<P>
<UL>
<LI>you are ultimately limited by "spurious free dynamic range"
</LI>
<LI>you need to have _some_ noise on the input channel,
otherwise you will be averaging the same number N times.
</LI>
<LI>the more noise you have, the greater your SFDR, but it
takes many more samples to compensate for the increased
noise
</LI>
<LI>if you feel the need to average samples for 2 seconds,
your signal will need to be _very_ slowly-varying, i.e.,
not varying more than your target uncertainty for the
entire 2 seconds.
</LI>
</UL>
</P>
<P>As you might have guessed, the comedi library has functions
to help you in your quest to accurately measure slowly varying
inputs.  I use these functions to measure thermocouple voltages
-- actually, the library functions came from a section of code
that was previously part of the thermocouple reading program.</P>
<P>The comedi self-calibration utility also uses these functions.
On some hardware, it is possible to tell it to measure an
internal stable voltage reference, which is typically going
to be very slowly varying -- on the kilosecond time scale
or more.  So it is reasonable to measure millions of samples,
to get a very accurate measurement of the A/D converter output
value that corresponds to the voltage reference.  Sometimes,
however, this is overkill, since there is no need to
perform a part-per-million calibration to a standard that
is only accurate to part-per-thousand.</P>



<H2><A NAME="ss5.3">5.3 Commands</A>
</H2>



<P>Many data acquisition devices have the capability to directly
control acquisition using either an on-board timer or an external
triggering input.  Comedi commands are used to control this kind
of acquisition.  The same structure (comedi_cmd) used to control
acquisition is used to query the capabilities of a device.</P>
<P>Commands specify a particular data acquisition sequence, which
is comprised of a number of scans.  Each scan is comprised of
a number of conversions, which usually corresponds to a single
A/D or D/A conversion.  The start and end of the sequence, and
the start and end of each scan, and each conversion is called an
event.</P>
<P>Each of these 5 types of events are caused by a triggering
source.  The source types are:</P>
<P>
<UL>
<LI>TRIG_NONE           don't ever cause event</LI>
<LI>TRIG_NOW            cause event to occur immediately</LI>
<LI>TRIG_FOLLOW (see notes below)</LI>
<LI>TRIG_TIME           cause event to occur at a particular time</LI>
<LI>TRIG_TIMER  cause event to occur repeatedly at a specific rate</LI>
<LI>TRIG_COUNT  cause event when count reaches specific value</LI>
<LI>TRIG_EXT            external signal causes event</LI>
<LI>TRIG_INT            internal signal causes event</LI>
</UL>
</P>
<P>Not all triggers are applicable to all events.  Supported triggers
for specific events depends significantly on your particular
device.  In addition, for every trigger type, there is a cooresponding
argument that specifies the rate, the count, which external signal,
etc.</P>
<P>TRIG_FOLLOW is a special type of trigger for scan_begin events that
triggers on the next lower level trigger, in this case, the trigger
for convert events.  It may or may not be supported.  Later, it may
also be used for start events if you want to chain multiple commands.</P>
<P>In particular, scan_end events will almost always be triggered on
TRIG_COUNT, with the argument being the number of channels in the
scan.  (Actually, samples in the scan, since on most boards you can
measure a single channel multiple times in a scan.)  Also, until
otherwise supported, start events can only be TRIG_NOW.</P>






<HR>
Next
<A HREF="comedilib-4.html">Previous</A>
<A HREF="comedilib.html#toc5">Contents</A>
</BODY>
</HTML>
