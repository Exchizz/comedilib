<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Comedi Documentation: Libcomedi Reference</TITLE>

 <LINK HREF="comedilib_reference.html#toc1" REL=contents>
</HEAD>
<BODY>
Next
Previous
<A HREF="comedilib_reference.html#toc1">Contents</A>
<HR>
<H2><A NAME="s1">1. Libcomedi Reference</A></H2>

<P>
<P>
<H2><A NAME="ss1.1">1.1 Constants and Macros</A>
</H2>

<P>
<P>
<P>
<H3>RANGE_LENGTH() <I>(deprecated)</I></H3>

<P>
<A NAME="RANGE_LENGTH"></A> <P><CODE>RANGE_LENGTH(rangetype)</CODE>
<P>
<P>Rangetype values are library-internal tokens that represent an
array of range information structures.  These numbers are primarily
used for communication between the kernel and library.
<P>
<P>The RANGE_LENGTH() macro returns the length of the array that is
specified by the rangetype token.
<P>
<P>The RANGE_LENGTH() macro is deprecated, and should not be used in
new applications.  It is scheduled to be removed from the header
file at version 1.0.  Binary compatibility may be broken for version
1.1.
<P>
<P>
<P>
<H2><A NAME="ss1.2">1.2 Data Types and Structures</A>
</H2>

<P>
<H3><A NAME="comedi_t"></A> comedi_t</H3>

<P>The data type <CODE>comedi_t</CODE> is used to represent an open Comedi
device.  A valid <CODE>comedi_t</CODE> pointer is returned by a successful
call to <CODE>comedi_open()</CODE>, and should be used for subsequent
access to the device.
It is a transparent type, and pointers to type <CODE>comedi_t</CODE>
should not be dereferenced.  
<P>
<P>
<P>
<H3><A NAME="sampl_t"></A> sampl_t</H3>

<P>The data type <CODE>sampl_t</CODE> is one of the generic types used to represent
data values in libcomedi.  It is used in a few places where a shorter
data type is useful, but is limited to 16 bits on the i386 architecture.
<P>
<P>
<P>
<H3><A NAME="lsampl_t"></A> lsampl_t</H3>

<P>The data type <CODE>lsampl_t</CODE> is one of the generic types used to represent
data values in libcomedi.  It is currently defined to be <CODE>unsigned int</CODE>.
<P>
<P>
<P>
<P>
<P>
<H3><A NAME="comedi_trig_struct"></A> comedi_trig_struct <I>(deprecated)</I></H3>

<P>
<P>The <CODE>comedi_trig</CODE> structure
<P>
<BLOCKQUOTE><CODE>
<PRE>
struct comedi_trig_struct{
        unsigned int subdev;            /* subdevice */
        unsigned int mode;              /* mode */
        unsigned int flags;
        unsigned int n_chan;            /* number of channels */
        unsigned int *chanlist;         /* channel/range list */
        sampl_t *data;                  /* data list, size depends on subd flags */
        unsigned int n;                 /* number of scans */
        unsigned int trigsrc;
        unsigned int trigvar;
        unsigned int trigvar1;
        unsigned int data_len;
        unsigned int unused[3];
}
</PRE>
</CODE></BLOCKQUOTE>
<P>The <CODE>comedi_trig</CODE> structure is a control structure used by the
COMEDI_TRIG ioctl, an older method of communicating
instructions to the driver and hardware.  Use of Comedi triggers is
deprecated, and should not be used in new applications.
<P>
<P>
<P>
<H3><A NAME="comedi_sv_t"></A> comedi_sv_t</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
struct comedi_sv_struct{
        comedi_t *dev;
        unsigned int subdevice;
        unsigned int chan;

        /* range policy */
        int range;
        int aref;
        
        /* number of measurements to average (for ai) */
        int n;

        lsampl_t maxdata;
}
</PRE>
</CODE></BLOCKQUOTE>
<P>The <CODE>comedi_sv_t</CODE> structure is used by the <CODE>comedi_sv_*()</CODE>
functions to provide a simple method of accurately measuring
slowly varying inputs.  See the relevant section for more
details.
<P>
<P>
<P>
<H2><A NAME="ss1.3">1.3 Functions</A>
</H2>

<P>
<P>
<H3><A NAME="comedi_close"></A> comedi_close()</H3>

<P>
<P><CODE>void comedi_close(comedi_t *it);</CODE>
<P>
<P>Closes a device previously opened by comedi_open().
<P>
<P>The return type of this function will change to <CODE>int</CODE>, in
order to match <CODE>fclose</CODE>.
<P>
<P>Source: <CODE>/lib/comedi.c</CODE>
<P>
<P>
<H3><A NAME="comedi_data_read"></A> comedi_data_read()</H3>

<P>
<P><CODE>int comedi_data_read(comedi_t *it,unsigned int subd,unsigned int chan,
unsigned int range,unsigned int aref,lsampl_t *data);</CODE>
<P>
<P>Reads a single sample on the channel that
is specified by the comedi device <CODE>it</CODE>, the
subdevice <CODE>subd</CODE>, and the channel <CODE>chan</CODE>.
For the A/D conversion (if appropriate),
the device is configured to use range specification
<CODE>range</CODE> and (if appropriate) analog reference type
<CODE>aref</CODE>.  Analog reference types that are not supported
by the device are silently ignored.
<P>
<P><CODE>comedi_data_read()</CODE> reads one data value from
the specified channel and places the 
data value that is read in the location pointed to by
<CODE>data</CODE>.
<P>
<P>On sucess, <CODE>comedi_data_read()</CODE> returns 0.  If there is an
error, -1 is returned.
<P>
<P>Valid analog reference numbers are:
<P>
<UL>
<LI>AREF_GROUND Reference to analog ground</LI>
<LI>AREF_COMMON Reference to analog common</LI>
<LI>AREF_DIFF           Differential reference</LI>
<LI>AREF_OTHER  Board-specific meaning</LI>
</UL>
<P>Valid data values returned by these function is an unsigned integer
less than or equal to <CODE>maxdata</CODE>, which is channel-dependent.
Conversion of these data value to physical units can be performed
by <CODE>
<A HREF="#comedi_to_phys">comedi_to_phys()</A></CODE>.
<P>Source: <CODE>/lib/data.c</CODE>
<P>
<P>
<H3>comedi_data_write()</H3>

<P>
<P><CODE>int comedi_data_write(comedi_t *it,unsigned int subd,unsigned int chan,
unsigned int range,unsigned int aref,lsampl_t data);</CODE>
<P>
<P>Writes a single sample on the channel that
is specified by the comedi device <CODE>it</CODE>, the
subdevice <CODE>subd</CODE>, and the channel <CODE>chan</CODE>.
For the D/A conversion (if appropriate), the device is
configured to use range specification
<CODE>range</CODE> and (if appropriate) analog reference type
<CODE>aref</CODE>.  Analog reference types that are not supported
by the device are silently ignored.
<P><CODE>comedi_data_write()</CODE> writes the data value
specified by the argument <CODE>data</CODE> to
the specified channel.
<P>On sucess, <CODE>comedi_data_write()</CODE> returns 0.  If there is an error, -1 is
returned.
<P>Valid analog reference numbers are:
<P>
<UL>
<LI>AREF_GROUND Reference to analog ground</LI>
<LI>AREF_COMMON Reference to analog common</LI>
<LI>AREF_DIFF           Differential reference</LI>
<LI>AREF_OTHER  Board-specific meaning</LI>
</UL>
<P>Valid data values used by these functions is an unsigned integer
less than or equal to <CODE>maxdata</CODE>, which is channel-dependent.
Conversion of physical units to these data value can be performed
by <CODE>
<A HREF="#comedi_from_phys">comedi_from_phys()</A></CODE>.
<P>Source: <CODE>/lib/data.c</CODE>
<P>
<P>
<P>
<H3>comedi_dio_bitfield();</H3>

<P><CODE>int comedi_dio_bitfield(comedi_t *it,unsigned int subd,unsigned
int write_mask,unsigned int *bits);</CODE>
<P>
<P>The function <CODE>comedi_dio_bitfield()</CODE> allows multiple channels to
be read simultaneously from a digital input or digital I/O device.
The parameter <CODE>write_mask</CODE> and the value pointed to by <CODE>bits</CODE>
are interpreted as bit fields, with the least significant bit
representing channel 0.  For each bit in <CODE>write_mask</CODE> that is
set, the cooresponding bit in <CODE>*bits</CODE> is written to the digital
output channel.  Each digital input channel is read, and the result
placed in the approprate bits in <CODE>*bits</CODE>.
<P>
<P>The current implementation reads and writes bits using separate
system calls, which is not ideal.  When the kernel driver supports
simultaneous reading/writing, this will be fixed in the library.
<P>
<P>It should be noted that it is not possible to access channels
greater than 31 using this function.
<P>
<P>Source: <CODE>/lib/dio.c</CODE>
<P>
<P>
<P>
<H3>comedi_dio_config()</H3>

<P><CODE>int comedi_dio_config(comedi_t *it,unsigned int subd,unsigned
int chan,unsigned int dir);</CODE>
<P>
<P>The function <CODE>comedi_dio_config</CODE> configures individual channels
in a digital I/O subdevice to be either input or output, depending
on the value of parameter <CODE>dir</CODE>.  Depending on the capabilities
of the hardware device, multiple channels may be affected by
a single call to <CODE>comedi_dio_config</CODE>.
<P>
<P>Valid directions are:
<UL>
<LI> COMEDI_INPUT</LI>
<LI> COMEDI_OUTPUT</LI>
</UL>
<P>Source: <CODE>/lib/dio.c</CODE>
<P>
<P>
<P>
<H3>comedi_dio_read()</H3>

<P><CODE>int comedi_dio_read(comedi_t *it,unsigned int subd,unsigned int
chan,unsigned int *bit);</CODE>
<P>
<P>The function reads the status of channel <CODE>chan</CODE> belonging to the digital
input subdevice <CODE>subd</CODE> of device <CODE>it</CODE>. The result, 0 or 1, is stored
in bit. Returns -1 on failure.
<P>
<P>This function is equivalent to <CODE>comedi_data_read(it,subd,chan,0,0,bit)</CODE>.
<P>
<P>Source: <CODE>/lib/dio.c</CODE>
<P>
<P>
<H3>comedi_dio_write()</H3>

<P><CODE>int comedi_dio_write(comedi_t *it,unsigned int subd,unsigned
int chan,unsigned int bit);</CODE>
<P>
<P>The function writes the value of <CODE>bit</CODE>, 0 or 1, to channel <CODE>chan</CODE>,
belonging to the digital output device <CODE>subd</CODE> of device <CODE>it</CODE>. Returns
-1 on failure.
<P>
<P>Source: <CODE>/lib/dio.c</CODE>
<P>
<P>
<H3>comedi_fileno()</H3>

<P>
<P><CODE>int comedi_fileno(comedi_t *it);</CODE>
<P>
<P>The function <CODE>comedi_fileno</CODE>
returns the integer descriptor for the handle <CODE>it</CODE>.  It
is equivalent to the standard function <CODE>fileno</CODE>.  If
<CODE>it</CODE> is an invalid <CODE>comedi_t</CODE> pointer, the function
returns -1 and sets the appropriate libcomedi error value.
<P>Source: <CODE>/lib/comedi.c</CODE>
<P>
<P>
<P>
<H3>comedi_find_range()</H3>

<P>
<P><CODE>int comedi_find_range(comedi_t *it, unsigned int subdevice, unsigned
int chan, unsigned int unit, double min, double max);</CODE>
<P>
<P>The function <CODE>comedi_find_range</CODE> tries to
locate the optimal (smallest) range for the channel <CODE>chan</CODE>
belonging to a <CODE>subdevice</CODE> of the comedi device <CODE>it</CODE>,
that includes both <CODE>min</CODE> and <CODE>max</CODE> in <CODE>units</CODE>.
If it finds a matching range, it returns its index.  If no
matching range is available, it returns -1.
<P>
<P>Valid units are:
<P>
<UL>
<LI>UNIT_volt           </LI>
<LI>UNIT_mA</LI>
<LI>UNIT_none</LI>
</UL>
<P>Source: <CODE>/lib/range.c</CODE>
<P>
<P>
<P>
<H3><A NAME="comedi_errno"></A> comedi_errno()</H3>

<P><CODE>int comedi_errno(void);</CODE>
<P>
<P>The function <CODE>comedi_errno()</CODE>
returns an integer describing the most recent comedilib error.  This
integer may be used as the <CODE>errnum</CODE> parameter for
<CODE>
<A HREF="#comedi_strerror">comedi_strerror()</A></CODE>.
<P>When a libcomedi function fails, it usually returns -1 or
NULL, depending on the return type.  An internal library
variable stores an error number, which can be retrieved with
<CODE>comedi_errno()</CODE>.  This error number can be
converted to a human-readable form by the functions
<CODE>
<A HREF="#comedi_perror">comedi_perror()</A></CODE>
and <CODE>
<A HREF="#comedi_strerror">comedi_strerror()</A></CODE>.
<P>These functions are intended to mimic the behavior of the
standard C library functions <CODE>perror()</CODE>,
<CODE>strerror</CODE>, and <CODE>errno()</CODE>.  In particular,
libcomedi functions sometimes return an error that is generated
by the C library; the Comedi error message in this case
is the same as the C library.
<P>Source: <CODE>/lib/error.c</CODE>
<P>
<P>
<P>
<H3>comedi_find_subdevice_by_type()</H3>

<P>
<P><CODE>int comedi_find_subdevice_by_type(comedi_t *it,int type,unsigned int
start_subdevice);</CODE>
<P>
<P>The function <CODE>comedi_find_subdevice_by_type</CODE> tries to
locate a subdevice belonging to comedi device <CODE>it</CODE>,
having type <CODE>type</CODE>, starting with the subdevice
<CODE>start_subdevice</CODE>.  If it finds the requested subdevice,
it returns its index.  If it does not locate the requested
subdevice, it returns -1 and sets the comedi error number to
"subdevice not found".  If there is an error, the function
returns -1 and sets the appropriate error.
<P>
<P>For subdevice types, see the manual page for the function
<CODE>
<A HREF="#comedi_get_subdevice_type">comedi_get_subdevice_type()</A></CODE>.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<P>
<H3><A NAME="comedi_from_phys"></A> comedi_from_phys()</H3>

<P>
<P><CODE>lsampl_t comedi_from_phys(double data, comedi_range *rng,
lsampl_t maxdata);</CODE>
<P>Converts data given in physical units (<CODE>data</CODE>) into sample values
(lsampl_t, between 0 and maxdata).  The parameter <CODE>rng</CODE>
represents the conversion information to use, and the parameter
<CODE>maxdata</CODE> represents the maximum possible data value for the
channel that the data will be written to.
<P>
<P>Source: <CODE>/lib/range.c</CODE>
<P>
<P>
<P>
<H3>comedi_get_board_name()</H3>

<P>
<P><CODE>char *comedi_get_board_name(comedi_t *it);</CODE>
<P>The function <CODE>comedi_get_board_name</CODE> returns a pointer
to a string containing the name of the device.  This pointer is
valid until the comedi descriptor <CODE>it</CODE> is closed.  This
function returns <CODE>NULL</CODE> if there is an error.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<P>
<H3>comedi_get_driver_name()</H3>

<P>
<P><CODE>char *comedi_get_driver_name(comedi_t *it);</CODE>
<P>The function <CODE>comedi_get_driver_name</CODE> returns a pointer
to a string containing the name of the driver being used by comedi
for the comedi device represented by <CODE>it</CODE>.  This pointer is
valid until the comedi descriptor <CODE>it</CODE> is closed.  This
function returns <CODE>NULL</CODE> if there is an error.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<P>
<H3>comedi_get_maxdata()</H3>

<P>
<P><CODE>lsampl_t comedi_get_maxdata(comedi_t *it,unsigned int
subdevice,unsigned int chan);</CODE>
<P>
<P>The function <CODE>comedi_get_maxdata()</CODE> returns the maximum
valid data value for channel <CODE>chan</CODE> of subdevice
<CODE>subdevice</CODE> belonging to the comedi device <CODE>it</CODE>
This function returns 0 on error.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<P>
<H3>comedi_get_n_channels()</H3>

<P>
<P><CODE>int comedi_get_n_channels(comedi_t *it,unsigned int subdevice);</CODE>
<P>The function <CODE>comedi_get_n_channels()</CODE> returns the number
of channels of the subdevice belonging to the comedi device <CODE>it</CODE>
and having index <CODE>subdevice</CODE>.  This function returns -1 on error.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<P>
<H3>comedi_get_n_ranges()</H3>

<P>
<P><CODE>int comedi_get_n_ranges(comedi_t *it,unsigned int subdevice, unsigned int
chan);</CODE>
<P>The function <CODE>comedi_get_n_ranges()</CODE> returns the number
of ranges of the channel <CODE>chan</CODE> belonging to the <CODE>subdevice</CODE>
of the comedi device <CODE>it</CODE>.  This function returns -1 on error.
<P>Source: <CODE>/lib/range.c</CODE>
<P>
<P>
<P>
<H3>comedi_get_n_subdevices()</H3>

<P>
<P><CODE>int comedi_get_n_subdevices(comedi_t *it);</CODE>
<P>The function <CODE>comedi_get_n_subdevices</CODE> returns the
number of subdevices associated with the comedi descriptor
<CODE>it</CODE>, or -1 if there is an error.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<P>
<H3>comedi_get_range()</H3>

<P>
<P><CODE>comedi_range * comedi_get_range(comedi_t *it,unsigned int subdevice,unsigned int chan,unsigned int
range);</CODE>
<P>The function <CODE>comedi_get_range</CODE> returns a pointer to a
comedi_range structure that contains information that can be used to
convert sample values to or from physical units.  The pointer is valid
until the comedi device <CODE>it</CODE> is closed.  If there is an
error, NULL is returned.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<H3>comedi_get_rangetype()</H3>

<P>
<P><CODE>int comedi_get_rangetype(comedi_t *it,unsigned int subdevice,unsigned int
chan);</CODE>
<P>The function <CODE>comedi_get_rangetype()</CODE> returns an integer
that represents the number of range specifications available for a
particular channel <CODE>chan</CODE> of the subdevice <CODE>subdevice</CODE>, as well as a conversion table to convert sample
values to/from physical units. 
<P>The macro
<CODE>RANGE_LENGTH(rangetype)</CODE>
can be used to determine the number of range specifications for a given
range type.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<H3><A NAME="comedi_get_subdevice_type"></A> comedi_get_subdevice_type()</H3>

<P>
<P><CODE>int comedi_get_subdevice_type(comedi_t *it,unsigned int subdevice);</CODE>
<P>The function <CODE>comedi_get_subdevice_type()</CODE> returns an
integer describing the type of subdevice that belongs to the comedi
device <CODE>it</CODE> and has the index <CODE>subdevice</CODE>.  The
function returns -1 is there is an error.
<P>Valid subdevice types are:
<P>
<UL>
<LI><CODE>COMEDI_SUBD_UNUSED</CODE>
Subdevice has no functionality, i.e., a place-holder.</LI>
<LI><CODE>COMEDI_SUBD_AI</CODE> Analog input</LI>
<LI><CODE>COMEDI_SUBD_AO</CODE> Analog output</LI>
<LI><CODE>COMEDI_SUBD_DI</CODE> Digital input</LI>
<LI><CODE>COMEDI_SUBD_DO</CODE> Digital output</LI>
<LI><CODE>COMEDI_SUBD_DIO</CODE>
Digital input/output.  Channels are configurable as to whether they
are inputs or outputs.</LI>
<LI><CODE>COMEDI_SUBD_COUNTER</CODE>    Counter</LI>
<LI><CODE>COMEDI_SUBD_TIMER</CODE>      Timer</LI>
<LI><CODE>COMEDI_SUBD_MEMORY</CODE>
Memory, e.g., EEPROM or dual-ported RAM</LI>
<LI><CODE>COMEDI_SUBD_CALIB</CODE>
Calibration DACs</LI>
<LI><CODE>COMEDI_SUBD_PROC</CODE>
Processor or DSP</LI>
</UL>
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<H3>comedi_get_timer() <I>(deprecated)</I></H3>

<P>
<P><CODE>int comedi_get_timer(comedi_t *it,unsigned int subdev, double
freq,unsigned int *trigvar, double *actual_freq);</CODE>
<P>
<P>The function <CODE>comedi_get_timer</CODE> converts the frequency <CODE>freq</CODE>
to a number suitable to send to the driver in a <CODE>comedi_trig</CODE>
structure.  This function remains for compatibility with very
old versions of Comedi, that converted sampling rates to timer
values in the libary.  This conversion is now done in the kernel,
and every device has the timer type <CODE>nanosec_timer</CODE>, indicating
that timer values are simply a time specified in nanoseconds.
<P>
<P>This function is deprecated and should not be used in new applications.
<P>
<P>Source: <CODE>/lib/timer.c</CODE>
<P>
<P>
<H3>comedi_get_version_code()</H3>

<P>
<P><CODE>int comedi_get_version_code(comedi_t *it);</CODE>
<P>
<P>The function <CODE>comedi_get_version_code()</CODE> returns the
version code of the currently running comedi module.  The version
code is of the form 0x01072b, which is the version code for
version 1.7.43.
<P>
<P>This function is of limited usefulness.  A typical mis-application
of this function is to use it to determine if a certain feature is
supported.  If the application needs
to know of the existence of a particular feature, an existence
test function should be written and put in the libcomedi source.
<P>Source: <CODE>/lib/get.c</CODE>
<P>
<P>
<H3>comedi_loglevel()</H3>

<P>
<P><CODE>int comedi_loglevel(int loglevel);</CODE>
<P>
<P>This function affects the output of debugging and error messages
from libcomedi.  By increasing the loglevel, additional debugging
information will be printed.  This function returns the previous
loglevel.  Error messages and debugging are printed to the
stream <CODE>stderr</CODE>.  The loglevel can also be affected by the
environment variable COMEDI_LOGLEVEL.
<P>
<P>In order to conserve resources, some debugging information is
disabled when libcomedi is compiled.
<P>
<P>The meaning of the loglevels is as follows:
<P>
<UL>
<LI><CODE>COMEDILIB_LOGLEVEL=0</CODE>

Comedilib prints nothing.
</LI>
<LI><CODE>COMEDILIB_LOGLEVEL=1</CODE>  (default)

Comedilib only prints error messages when there is a
self-consistency error (i.e., internal bug).
</LI>
<LI><CODE>COMEDILIB_LOGLEVEL=2</CODE>

Comedilib prints an error message when an invalid
parameter is passed to comedilib.
</LI>
<LI><CODE>COMEDILIB_LOGLEVEL=3</CODE>

Comedilib prints an error message whenever an error is generated
in the comedilib library or is generated in the C library when
called by comedilib.
</LI>
<LI><CODE>COMEDILIB_LOGLEVEL=4</CODE>

Comedilib prints a lot of debugging messages.
</LI>
</UL>
<P>Bugs: Libcomedi doesn't currently have much debugging information.
<P>Source: <CODE>/lib/error.c</CODE>
<P>
<P>
<H3>comedi_open()</H3>

<P>
<P><CODE>comedi_t *comedi_open(char *filename);</CODE>
<P>Opens a comedi device specified by the filename <CODE>filename</CODE>.
Returns NULL on error.  On sucess, it returns a handle that is
given as a parameter to other libcomedi functions.
<P>
<P>You are not supposed to have access to the internals of the
<CODE>comedi_t</CODE> structure.
<P>Bugs: Not strictly identical to <CODE>fopen</CODE>
<P>Source: <CODE>/lib/comedi.c</CODE>
<P>
<P>
<P>
<H3><A NAME="comedi_perror"></A> comedi_perror()</H3>

<P>
<P><CODE>void comedi_perror(const char *s);</CODE>
<P>When a comedilib function fails, it usually returns -1 or
NULL, depending on the return type.  An internal library
variable stores an error number, which can be retrieved with 
<CODE>
<A HREF="#comedi_errno">comedi_errno()</A></CODE>.
This error number can be
converted to a human-readable form by the functions 
<CODE>comedi_perror()</CODE>
and <CODE>
<A HREF="#comedi_strerror">comedi_strerror()</A></CODE>.
<P>These functions are intended to mimic the behavior of the
standard C library functions <CODE>perror()</CODE>,
<CODE>strerror</CODE>, and <CODE>errno()</CODE>.  In particular,
comedilib functions sometimes return an error that is generated
inside the C library; the comedi error message in this case
is the same as the C library.
<P>The function <CODE>comedi_perror()</CODE> prints an error
message to stderr.  The error message consists of the
argument string, a colon, a space, a description of the error
condition, and a new line.
<P>Bugs: Does not support internationalization.
<P>Source: <CODE>/lib/error.c</CODE>
<P>
<P>
<P>
<H3><A NAME="comedi_strerror"></A> comedi_strerror()</H3>

<P>
<P><CODE>*comedi_strerror(int errnum);</CODE>
<P>When a comedilib function fails, it usually returns -1 or
NULL, depending on the return type.  An internal library
variable stores an error number, which can be retrieved with
<CODE>
<A HREF="#comedi_errno">comedi_errno()</A></CODE>.  This error number can be
converted to a human-readable form by the functions
<CODE>
<A HREF="#comedi_perror">comedi_perror()</A></CODE>
and <CODE>comedi_strerror()</CODE>.
<P>These functions are intended to mimic the behavior of the
standard C library functions <CODE>perror()</CODE>,
<CODE>strerror</CODE>, and <CODE>errno()</CODE>.  In particular,
comedilib functions sometimes return an error that is generated
inside the C library; the comedi error message in this case
is the same as the C library.
<P>The function <CODE>comedi_strerror()</CODE> returns a pointer to a
character string
describing the comedilib error <CODE>errnum</CODE>.  The persistence
of the returned pointer is undefined, and should not be trusted
after the next libcomedi call.  An unrecognized error number will
return a pointer to the string "undefined error", or similar.
<P>Bugs: Does not support internationalization.
<P>Source: <CODE>/lib/error.c</CODE>
<P>
<P>
<P>
<H3>comedi_sv_init()</H3>

<P>
<P><CODE>int comedi_sv_init(comedi_sv_t *sv,comedi_t *dev,unsigned int subd,
unsigned int chan);</CODE>
<P>
<P><CODE>comedi_sv_init</CODE> initializes the slow varying comedi structure
<CODE>sv</CODE> of the device <CODE>dev</CODE>, the subdevice <CODE>subd</CODE> (analog input) and
the channel <CODE>chan</CODE>.
The slow varying comedi structure <CODE>sv</CODE> of type <CODE>
<A HREF="#comedi_sv_t">comedi_sv_t</A></CODE>
specifies the signal measurement.  The default number of averaged
samples is 100.  Returns zero on success, -1 on error.
<P>Bugs: comedi_sv_* was very poorly designed.
<P>Source: <CODE>/lib/sv.c</CODE>
<P>
<P>
<P>
<H3>comedi_sv_update()</H3>

<P>
<P><CODE>int comedi_sv_update(comedi_sv_t *sv);</CODE>
<P>The function <CODE>comedi_sv_update</CODE> updates the slow varying comedi structure
<CODE>sv</CODE>.
Returns zero on success, -1 on error.
<P>Source: <CODE>/lib/sv.c</CODE>
<P>
<P>
<P>
<H3>int comedi_sv_measure()</H3>

<P>
<P><CODE>int comedi_sv_measure(comedi_sv_t *it,double *data);</CODE>
<P><CODE>comedi_sv_measure</CODE> measures the slow variing signal. The measurement
is specified by the slow varying comedi structure <CODE>sv</CODE>, the result is
stored in <CODE>data</CODE>.
On success returns the number of samples, -1 on error.
<P>Source: <CODE>/lib/sv.c</CODE>
<P>
<P>
<P>
<H3><A NAME="comedi_to_phys"></A> comedi_to_phys()</H3>

<P>
<P><CODE>double comedi_to_phys(lsampl_t data, comedi_range *rng,
lsampl_t maxdata);</CODE>
<P>Converts data given in sample values (lsampl_t, between 0 and
maxdata) into physical units (double).  The parameter <CODE>rng</CODE>
represents the conversion information to use, and the parameter
<CODE>maxdata</CODE> represents the maximum possible data value for the
channel that the data was read.
<P>Source: <CODE>/lib/range.c</CODE>
<P>
<P>
<P>
<H3>comedi_trigger() <I>(deprecated)</I></H3>

<P>
<P><CODE>int comedi_trigger(comedi_t *it,comedi_trig *trig);</CODE>
<P>The function <CODE>comedi_trigger</CODE> instructs comedi to
perform the command specified by the 
<A HREF="#comedi_trig_struct">trigger structure</A> <CODE>trig</CODE>.  Results depend on
the particular command being issued.  If there is an
error, -1 is returned.
<P>Lifetime: removal at 1.0.
<P>Source: <CODE>/lib/comedi.c</CODE>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<P>
<H3>comedi_get_timer()</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
int comedi_get_timer(comedi_t *it,unsigned int subdev,double freq,unsigned int *trigvar,
        double *actual_freq);
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<P>
<P>
<HR>
Next
Previous
<A HREF="comedilib_reference.html#toc1">Contents</A>
</BODY>
</HTML>
