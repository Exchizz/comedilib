%{
/*
    lib/calib_yacc.y
    code for parsing calibration file, generated by bison

    Copyright (C) 2003 Frank Mori Hess <fmhess@users.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation, version 2.1
    of the License.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
    USA.
*/

#include <stdio.h>
#include "libinternal.h"
#include <string.h>
#include <stdlib.h>

#define YYERROR_VERBOSE

struct calibration_file_contents file_contents;
static struct caldac_setting caldac;
static int cal_index;

static void free_calibration_setting( struct calibration_setting *setting )
{
	if( setting->channels );
	{
		free( setting->channels );
		setting->channels = NULL;
		setting->num_channels = 0;
	}
	if( setting->ranges );
	{
		free( setting->ranges );
		setting->ranges = NULL;
		setting->num_ranges = 0;
	}
	setting->num_arefs = 0;
	if( setting->caldacs );
	{
		free( setting->caldacs );
		setting->caldacs = NULL;
		setting->num_caldacs = 0;
	}
}

static void free_calibrations( struct calibration_file_contents *file_contents )
{
	int i;

	if( file_contents->calibrations == NULL ) return;

	for( i = 0; i < file_contents->num_calibrations; i++ )
	{
		free_calibration_setting( &file_contents->calibrations[ i ] );
	}
	file_contents->calibrations = NULL;
}

static int add_calibration_setting( struct calibration_file_contents *file_contents )
{
	struct calibration_setting *temp;

	temp = realloc( file_contents->calibrations,
		( file_contents->num_calibrations + 1 ) * sizeof( struct calibration_setting ) );
	if( temp == NULL ) return -1;
	file_contents->calibrations = temp;
	memset( &file_contents->calibrations[ file_contents->num_calibrations ],
		0, sizeof( struct calibration_setting ) );

	file_contents->num_calibrations++;
	return 0;
}

static struct calibration_setting* current_setting( struct calibration_file_contents *file_contents )
{
	int retval;

	while( cal_index >= file_contents->num_calibrations )
	{
		retval = add_calibration_setting( file_contents );
		if( retval < 0 ) return NULL;
	}
	return &file_contents->calibrations[ cal_index ];
}

static int add_channel( struct calibration_file_contents *file_contents, int channel )
{
	int *temp;
	struct calibration_setting *setting;

	setting = current_setting( file_contents );
	if( setting == NULL ) return -1;

	temp = realloc( setting->channels, ( setting->num_channels + 1 ) * sizeof( int ) );
	if( temp == NULL ) return -1;
	setting->channels = temp;
	setting->channels[ setting->num_channels++ ] = channel;
	return 0;
}

static int add_range( struct calibration_file_contents *file_contents, int range )
{
	int *temp;
	struct calibration_setting *setting;

	setting = current_setting( file_contents );
	if( setting == NULL ) return -1;

	temp = realloc( setting->ranges, ( setting->num_ranges + 1 ) * sizeof( int ) );
	if( temp == NULL ) return -1;
	setting->ranges = temp;
	setting->ranges[ setting->num_ranges++ ] = range;
	return 0;
}

static int add_aref( struct calibration_file_contents *file_contents, int aref )
{
	struct calibration_setting *setting;

	setting = current_setting( file_contents );
	if( setting == NULL ) return -1;

	if( setting->num_arefs >= sizeof( setting->arefs ) /
		sizeof( setting->arefs[ 0 ] ) )
		return -1;
	setting->arefs[ setting->num_arefs++ ] = aref;
	return 0;
}

static int add_caldac( struct calibration_file_contents *file_contents,
	struct caldac_setting caldac )
{
	struct caldac_setting *temp;
	struct calibration_setting *setting;

	setting = current_setting( file_contents );
	if( setting == NULL ) return -1;

	temp = realloc( setting->caldacs, ( setting->num_caldacs + 1 ) *
		sizeof( struct caldac_setting ) );
	if( temp == NULL ) return -1;
	setting->caldacs = temp;
	setting->caldacs[ setting->num_caldacs++ ] = caldac;
	return 0;
}

static void init_calib_parse( void )
{
	memset( &file_contents, 0, sizeof( file_contents ) );
	cal_index = 0;
}

extern void cleanup_calibration_parse( void )
{
	if( file_contents.driver_name )
	{
		free( file_contents.driver_name );
		file_contents.driver_name = NULL;
	}
	if( file_contents.board_name )
	{
		free( file_contents.board_name );
		file_contents.board_name = NULL;
	}
	free_calibrations( &file_contents );
}

extern const struct calibration_file_contents* parse_calibration_file( FILE *file )
{
	calib_yyrestart( file );
	init_calib_parse();
	if( calib_yyparse() ) return NULL;
	return &file_contents;
}

%}

%union
{
	int  ival;
	char *sval;
}

%token T_DRIVER_NAME T_BOARD_NAME T_CALIBRATIONS T_SUBDEVICE T_CHANNELS
%token T_RANGES T_AREFS T_CALDACS T_CHANNEL T_VALUE T_NUMBER T_STRING
%token T_ASSIGN

%type <ival> T_NUMBER
%type <sval> T_STRING

%%

	input: '{' hash '}'
		| error
			{
				fprintf(stderr, "input error on line %i\n", @1.first_line );
				return -1;
			}
		;

	hash: /* empty */
		| hash_element
		| hash_element ',' hash
		;

	hash_element: T_DRIVER_NAME T_ASSIGN T_STRING
		{
			if( file_contents.driver_name != NULL ) YYABORT;
			file_contents.driver_name = strdup( $3 );
		}
		| T_BOARD_NAME T_ASSIGN T_STRING
		{
			if( file_contents.board_name != NULL ) YYABORT;
			file_contents.board_name = strdup( $3 );
		}
		| T_CALIBRATIONS T_ASSIGN '[' calibrations_array ']'
		;

	calibrations_array: /* empty */
		| '{' calibration_setting '}'
		| '{' calibration_setting '}' ',' calibrations_array
		;

	calibration_setting: /* empty */ { cal_index++; }
		| calibration_setting_element
		| calibration_setting_element ',' calibration_setting
		;

	calibration_setting_element: T_SUBDEVICE T_ASSIGN T_NUMBER
		{
			struct calibration_setting *setting;
			setting = current_setting( &file_contents );
			if( setting == NULL ) YYABORT;
			setting->subdevice = $3;
		}
		| T_CHANNELS T_ASSIGN '[' channels_array ']'
		| T_RANGES T_ASSIGN '[' ranges_array ']'
		| T_AREFS T_ASSIGN '[' arefs_array ']'
		| T_CALDACS T_ASSIGN '[' caldacs_array ']'
		;

	channels_array: /* empty */
		| channel
		| channel ',' channels_array
		;

	channel: T_NUMBER { add_channel( &file_contents, $1 ); }
		;

	ranges_array: /* empty */
		| range
		| range ',' ranges_array
		;

	range: T_NUMBER { add_range( &file_contents, $1 ); }
		;

	arefs_array: /* empty */
		| aref
		| aref ',' arefs_array
		;

	aref: T_NUMBER { add_aref( &file_contents, $1 ); }
		;

	caldacs_array: /* empty */
		| '{' caldac '}'
		| '{' caldac '}' ',' caldacs_array
		;

	caldac: /* empty */ { add_caldac( &file_contents, caldac ); }
		| caldac_element
		| caldac_element ',' caldac
		;

	caldac_element: T_SUBDEVICE T_ASSIGN T_NUMBER { caldac.subdevice = $3; }
		| T_CHANNEL T_ASSIGN T_NUMBER { caldac.channel = $3; }
		| T_VALUE T_ASSIGN T_NUMBER { caldac.value = $3; }
		;

%%

void calib_yyerror(char *s)
{
	fprintf(stderr, "%s\n", s);
}



